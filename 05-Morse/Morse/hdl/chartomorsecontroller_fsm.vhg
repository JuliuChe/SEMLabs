--
-- VHDL Architecture Morse.charToMorseController.fsm
--
-- Created:
--          by - julien.chevalle1.UNKNOWN (WE2330802)
--          at - 13:36:36 12.04.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF charToMorseController IS

    TYPE STATE_TYPE IS (
        waitForChar,
        storeChar,
        sendDotStart,
        sendDotWait,
        sendDotSpacerStart,
        sendDotSpacerWait,
        sendDotDotStart,
        sendDotDotWait,
        sendDotDashStart,
        sendDotDashWait,
        sendDashStart,
        sendDashWait,
        sendDahsSpacerStart,
        sendDashSpacerWait,
        sendDashDotStart,
        sendDashDashStart,
        sendDashDotWait,
        sendDashDashWait,
        popChar,
        popChar1
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= waitForChar;
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        char,
        charNotReady,
        counterDone,
        current_state
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN waitForChar => 
                IF (charNotReady = '0') THEN 
                    next_state <= storeChar;
                ELSE
                    next_state <= waitForChar;
                END IF;
            WHEN storeChar => 
                IF (to_integer(unsigned(char)) = 'e' or
                    to_integer(unsigned(char)) = 'i' or
                    to_integer(unsigned(char)) = 'a') THEN 
                    next_state <= sendDotStart;
                ELSIF (to_integer(unsigned(char)) = 't' or
                       to_integer(unsigned(char)) = 'n' or
                       to_integer(unsigned(char)) = 'm') THEN 
                    next_state <= sendDashStart;
                ELSE
                    next_state <= popChar1;
                END IF;
            WHEN sendDotStart => 
                next_state <= sendDotWait;
            WHEN sendDotWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDotWait;
                ELSIF (to_integer(unsigned(char)) = 'e') THEN 
                    next_state <= popChar1;
                ELSE
                    next_state <= sendDotSpacerStart;
                END IF;
            WHEN sendDotSpacerStart => 
                next_state <= sendDotSpacerWait;
            WHEN sendDotSpacerWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDotSpacerWait;
                ELSIF (to_integer(unsigned(char)) = 'i') THEN 
                    next_state <= sendDotDotStart;
                ELSE
                    next_state <= sendDotDashStart;
                END IF;
            WHEN sendDotDotStart => 
                next_state <= sendDotDotWait;
            WHEN sendDotDotWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDotDotWait;
                ELSE
                    next_state <= popChar1;
                END IF;
            WHEN sendDotDashStart => 
                next_state <= sendDotDashWait;
            WHEN sendDotDashWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDotDashWait;
                ELSE
                    next_state <= popChar1;
                END IF;
            WHEN sendDashStart => 
                next_state <= sendDashWait;
            WHEN sendDashWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDashWait;
                ELSIF (to_integer(unsigned(char)) = 't') THEN 
                    next_state <= popChar1;
                ELSE
                    next_state <= sendDahsSpacerStart;
                END IF;
            WHEN sendDahsSpacerStart => 
                next_state <= sendDashSpacerWait;
            WHEN sendDashSpacerWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDashSpacerWait;
                ELSIF (to_integer(unsigned(char)) = 'i') THEN 
                    next_state <= sendDashDotStart;
                ELSE
                    next_state <= sendDashDashStart;
                END IF;
            WHEN sendDashDotStart => 
                next_state <= sendDashDotWait;
            WHEN sendDashDashStart => 
                next_state <= sendDashDashWait;
            WHEN sendDashDotWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDashDotWait;
                ELSE
                    next_state <= popChar1;
                END IF;
            WHEN sendDashDashWait => 
                IF (counterDone = '0') THEN 
                    next_state <= sendDashDashWait;
                ELSE
                    next_state <= popChar1;
                END IF;
            WHEN popChar => 
                IF (counterDone = '1') THEN 
                    next_state <= waitForChar;
                ELSE
                    next_state <= popChar;
                END IF;
            WHEN popChar1 => 
                next_state <= popChar;
            WHEN OTHERS =>
                next_state <= waitForChar;
        END CASE;
    END PROCESS nextstate_proc;
 
    -----------------------------------------------------------------
    output_proc : PROCESS ( 
        current_state
    )
    -----------------------------------------------------------------
    BEGIN
        -- Default Assignment
        morseOut <= '0';
        startCounter <= '0';
        unitNb <= (others => '0');
        readChar <= '0';

        -- Combined Actions
        CASE current_state IS
            WHEN sendDotStart => 
                startCounter <= '1';
            WHEN sendDotWait => 
                unitNb <= to_unsigned(1, unitNb'length);
                morseOut <= '1';
            WHEN sendDotSpacerStart => 
                startCounter <= '1';
            WHEN sendDotSpacerWait => 
                unitNb <= to_unsigned(1, unitNb'length);
            WHEN sendDotDotStart => 
                startCounter <= '1';
            WHEN sendDotDotWait => 
                unitNb <= to_unsigned(1, unitNb'length);
                morseOut <= '1';
            WHEN sendDotDashStart => 
                startCounter <= '1';
            WHEN sendDotDashWait => 
                unitNb <= to_unsigned(3, unitNb'length);
                morseOut <= '1';
            WHEN sendDashStart => 
                startCounter <= '1';
            WHEN sendDashWait => 
                unitNb <= to_unsigned(3, unitNb'length);
                morseOut <= '1';
            WHEN sendDahsSpacerStart => 
                startCounter <= '1';
            WHEN sendDashSpacerWait => 
                unitNb <= to_unsigned(1, unitNb'length);
            WHEN sendDashDotStart => 
                startCounter <= '1';
            WHEN sendDashDashStart => 
                startCounter <= '1';
            WHEN sendDashDotWait => 
                unitNb <= to_unsigned(1, unitNb'length);
                morseOut <= '1';
            WHEN sendDashDashWait => 
                unitNb <= to_unsigned(3, unitNb'length);
                morseOut <= '1';
            WHEN popChar => 
                unitNb <= to_unsigned(3, unitNb'length);
            WHEN popChar1 => 
                readChar <= '1';
                startCounter <= '1';
            WHEN OTHERS =>
                NULL;
        END CASE;
    END PROCESS output_proc;
 
END fsm;
