-- VHDL Entity Board.morse_ebs2.symbol
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:49:40 28.04.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY morse_ebs2 IS
    GENERIC( 
        bitNb : positive := 16
    );
    PORT( 
        RxD           : IN     std_ulogic;
        clock         : IN     std_ulogic;
        morseIn       : IN     std_uLogic;
        reset_N       : IN     std_ulogic;
        RxD_synch     : OUT    std_ulogic;
        TxD           : OUT    std_ulogic;
        morseEnvelope : OUT    std_ulogic;
        morseOut      : OUT    std_ulogic
    );

-- Declarations

END morse_ebs2 ;





-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Morse.morseDecoder.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY morseDecoder IS
    GENERIC( 
        clockFrequency : real     := 100.0E6;
        uartBaudRate   : real     := 115.2E3;
        uartDataBitNb  : positive := 8;
        unitDuration   : real     := 100.0E-3;
        toneFrequency  : real     := 300.0;
        deglitchBitNb  : natural  := 8
    );
    PORT( 
        morseCode     : IN     std_ulogic;
        clock         : IN     std_ulogic;
        reset         : IN     std_ulogic;
        TxD           : OUT    std_ulogic;
        morseEnvelope : OUT    std_ulogic
    );

-- Declarations

END morseDecoder ;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_bram ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library Common;
  use Common.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




-- VHDL Entity Morse.morseToCharDecoder.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY morseToCharDecoder IS
    GENERIC( 
        unitCountDivide : positive := 100;
        unitCountBitNb  : positive := 2;
        characterBitNb  : positive := 8
    );
    PORT( 
        clock          : IN     std_ulogic;
        reset          : IN     std_ulogic;
        charValid      : OUT    std_ulogic;
        symbolDuration : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        symbolValid    : IN     std_ulogic;
        symbolValue    : IN     std_ulogic;
        charOut        : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0)
    );

-- Declarations

END morseToCharDecoder ;





ARCHITECTURE studentVersion OF morseToCharDecoder IS
BEGIN

  charValid <= '0';
  charOut <= (others => '0');

END ARCHITECTURE studentVersion;




-- VHDL Entity Morse.envelopeRetreiver.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY envelopeRetreiver IS
    GENERIC( 
        toneDivide    : positive := 100E3;
        deglitchBitNb : positive := 8
    );
    PORT( 
        clock         : IN     std_ulogic;
        reset         : IN     std_ulogic;
        morseWithTone : IN     std_ulogic;
        morseEnvelope : OUT    std_ulogic
    );

-- Declarations

END envelopeRetreiver ;





library Common;
  use Common.CommonLib.all;

ARCHITECTURE studentVersion OF envelopeRetreiver IS
BEGIN

  morseEnvelope <= '0';

END ARCHITECTURE studentVersion;




-- VHDL Entity Morse.symbolLengthCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY symbolLengthCounter IS
    GENERIC( 
        unitCountDivide : positive := 100;
        unitCountBitNb  : positive := 2
    );
    PORT( 
        clock          : IN     std_ulogic;
        reset          : IN     std_ulogic;
        morseCode      : IN     std_ulogic;
        symbolDuration : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        symbolValid    : OUT    std_ulogic;
        symbolValue    : OUT    std_ulogic
    );

-- Declarations

END symbolLengthCounter ;





library Common;
  use Common.CommonLib.all;

ARCHITECTURE studentVersion OF symbolLengthCounter IS
BEGIN

  symbolValid <= '0';
  symbolValue <= '0';
  symbolDuration <= (others => '0');

END ARCHITECTURE studentVersion;




-- VHDL Entity RS232.serialPortTransmitter.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 13:21:39 08/07/23
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortTransmitter IS
    GENERIC( 
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        stopBitNb      : positive := 1
    );
    PORT( 
        TxD    : OUT    std_ulogic;
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic;
        busy   : OUT    std_ulogic
    );

-- Declarations

END serialPortTransmitter ;





--===========================================================================--
--  Design units : CoCa.serialPortTransmitter.rtl
--
--  File name : serialPortTransmitter.vhd
--
--  Purpose : Transmit a 8 bit data word over a serial line
--            add start and stop bits
--
--  Parameters : dataBitNb : number of data bits
--               stopBitNb : number of stop bits
--
--  
--
--  Errors: : None known
--
--  Library : Common
--
--  Dependencies : None
--
--  Author : 
--  Haute ecole d'ingenierie (HEI/HES-SO)
--  Institut systemes industriels (ISI)
--  Rue de l'industrie 23
--  1950 Sion
--  Switzerland (CH)
--
--  Simulator : Mentor ModelSim V10.7c
------------------------------------------------
--  Revision list
--  Version Author Date Changes
--
--  V1.0 04.04.2022 - First version
--===========================================================================--

library Common;
  use Common.CommonLib.all;

architecture RTL of serialPortTransmitter is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal txData: unsigned(dataBitNb-1 downto 0);
  signal send1: std_uLogic;
  signal txShiftEnable: std_uLogic;
  signal txShiftReg: unsigned(dataBitNb+stopBitNb downto 0);
  signal txSendingByte: std_uLogic;
  signal txSendingByteAndStop: std_uLogic;

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterReset = '1' then
        dividerCounter <= to_unsigned(1, dividerCounter'length);
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter, send1)
  begin
    if dividerCounter = baudRateDivide then
      dividerCounterReset <= '1';
    elsif send1 = '1' then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  txShiftEnable <= dividerCounterReset;

  storeData: process(reset, clock)
  begin
    if reset = '1' then
      txData <= (others => '1');
    elsif rising_edge(clock) then
      if send = '1' then
        txData <= unsigned(dataIn);
      end if;
    end if;
  end process storeData;

  delaySend: process(reset, clock)
  begin
    if reset = '1' then
      send1 <= '0';
    elsif rising_edge(clock) then
      send1 <= send;
    end if;
  end process delaySend;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      txShiftReg <= (others => '1');
    elsif rising_edge(clock) then
      if txShiftEnable = '1' then
        if send1 = '1' then
          txShiftReg <= (others => '1');                 -- stop bits
          txShiftReg(0) <= '0';                          -- start bit
          txShiftReg(txData'high+1 downto 1) <= txData;  -- data
          txShiftReg(txShiftReg'high) <= '0';            -- end flag
        else
          txShiftReg <= shift_right(txShiftReg, 1);
          txShiftReg(txShiftReg'high) <= '1';
        end if;
      end if;
    end if;
  end process shiftReg;

  txSendingByte <= '1' when
    (txShiftReg(txShiftReg'high downto 1) /= (txShiftReg'high downto 1 => '1'))
    else '0';

  txSendingByteAndStop <= '1' when
    txShiftReg /= (txShiftReg'high downto 0 => '1')
    else '0';

  TxD <= txShiftReg(0) when txSendingByte = '1' else '1';
  busy <= txSendingByteAndStop or send1 or send;

end RTL;




--
-- VHDL Architecture Morse.morseDecoder.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 08:02:13 08.05.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Memory;
LIBRARY Morse;
LIBRARY RS232;

ARCHITECTURE struct OF morseDecoder IS

    -- Architecture declarations
    constant unitCountBitNb: positive := 3;
    constant fifoDepth : positive := 8;

    -- Internal signal declarations
    SIGNAL symbolValue    : std_ulogic;
    SIGNAL symbolValid    : std_ulogic;
    SIGNAL symbolDuration : unsigned(unitCountBitNb-1 DOWNTO 0);
    SIGNAL charValid      : std_ulogic;
    SIGNAL charOut        : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL txWord         : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL txBusy         : std_ulogic;
    SIGNAL txSend         : std_ulogic;
    SIGNAL txFifoEmpty    : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL morseEnvelope_internal : std_ulogic;


    -- Component Declarations
    COMPONENT FIFO_bram
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT envelopeRetreiver
    GENERIC (
        toneDivide    : positive := 100E3;
        deglitchBitNb : positive := 8
    );
    PORT (
        clock         : IN     std_ulogic ;
        reset         : IN     std_ulogic ;
        morseWithTone : IN     std_ulogic ;
        morseEnvelope : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT morseToCharDecoder
    GENERIC (
        unitCountDivide : positive := 100;
        unitCountBitNb  : positive := 2;
        characterBitNb  : positive := 8
    );
    PORT (
        clock          : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        charValid      : OUT    std_ulogic ;
        symbolDuration : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        symbolValid    : IN     std_ulogic ;
        symbolValue    : IN     std_ulogic ;
        charOut        : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT symbolLengthCounter
    GENERIC (
        unitCountDivide : positive := 100;
        unitCountBitNb  : positive := 2
    );
    PORT (
        clock          : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        morseCode      : IN     std_ulogic ;
        symbolDuration : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        symbolValid    : OUT    std_ulogic ;
        symbolValue    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortTransmitter
    GENERIC (
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        stopBitNb      : positive := 1
    );
    PORT (
        TxD    : OUT    std_ulogic ;
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic ;
        busy   : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
    FOR ALL : envelopeRetreiver USE ENTITY Morse.envelopeRetreiver;
    FOR ALL : morseToCharDecoder USE ENTITY Morse.morseToCharDecoder;
    FOR ALL : serialPortTransmitter USE ENTITY RS232.serialPortTransmitter;
    FOR ALL : symbolLengthCounter USE ENTITY Morse.symbolLengthCounter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 2 eb2
    process(reset, clock)
      begin
        if reset = '1' then
          txSend <= '0';
        elsif rising_edge(clock) then
          if ( (txFifoEmpty = '0') and (txBusy = '0') ) then
            txSend <= '1';
          else
            txSend <= '0';
          end if;
        end if;
      end process;
          


    -- Instance port mappings.
    I0 : FIFO_bram
        GENERIC MAP (
            dataBitNb => uartDataBitNb,
            depth     => fifoDepth
        )
        PORT MAP (
            write   => charValid,
            clock   => clock,
            reset   => reset,
            dataOut => txWord,
            read    => txSend,
            dataIn  => charOut,
            empty   => txFifoEmpty,
            full    => OPEN
        );
    I_env : envelopeRetreiver
        GENERIC MAP (
            toneDivide    => integer(clockFrequency/toneFrequency + 0.5),
            deglitchBitNb => deglitchBitNb
        )
        PORT MAP (
            clock         => clock,
            reset         => reset,
            morseWithTone => morseCode,
            morseEnvelope => morseEnvelope_internal
        );
    I_dec : morseToCharDecoder
        GENERIC MAP (
            unitCountDivide => integer(clockFrequency*unitDuration + 0.5),
            unitCountBitNb  => unitCountBitNb,
            characterBitNb  => uartDataBitNb
        )
        PORT MAP (
            clock          => clock,
            reset          => reset,
            charValid      => charValid,
            symbolDuration => symbolDuration,
            symbolValid    => symbolValid,
            symbolValue    => symbolValue,
            charOut        => charOut
        );
    I_len : symbolLengthCounter
        GENERIC MAP (
            unitCountDivide => integer(clockFrequency*unitDuration + 0.5),
            unitCountBitNb  => unitCountBitNb
        )
        PORT MAP (
            clock          => clock,
            reset          => reset,
            morseCode      => morseEnvelope_internal,
            symbolDuration => symbolDuration,
            symbolValid    => symbolValid,
            symbolValue    => symbolValue
        );
    I_tx : serialPortTransmitter
        GENERIC MAP (
            dataBitNb      => uartDataBitNb,
            baudRateDivide => integer(clockFrequency/uartBaudRate + 0.5)
        )
        PORT MAP (
            TxD    => TxD,
            clock  => clock,
            reset  => reset,
            dataIn => txWord,
            send   => txSend,
            busy   => txBusy
        );

    -- Implicit buffered output assignments
    morseEnvelope <= morseEnvelope_internal;

END struct;




-- VHDL Entity Morse.morseEncoder.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY morseEncoder IS
    GENERIC( 
        clockFrequency : real     := 100.0E6;
        uartBaudRate   : real     := 115.2E3;
        uartDataBitNb  : positive := 8;
        unitDuration   : real     := 100.0E-3;
        toneFrequency  : real     := 300.0
    );
    PORT( 
        morseCode : OUT    std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        RxD       : IN     std_ulogic
    );

-- Declarations

END morseEncoder ;





-- VHDL Entity Morse.charToMorse.symbol
--
-- Created:
--          by - julien.chevalle1.UNKNOWN (WE2330802)
--          at - 14:20:44 12.04.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY charToMorse IS
    GENERIC( 
        characterBitNb  : positive := 8;
        unitCountDivide : positive := 10E3
    );
    PORT( 
        morseOut     : OUT    std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        charIn       : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        readChar     : OUT    std_ulogic;
        charNotReady : IN     std_ulogic
    );

-- Declarations

END charToMorse ;





-- VHDL Entity Morse.unitCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY unitCounter IS
    GENERIC( 
        unitCountDivide : positive := 10E3;
        unitCountBitNb  : positive := 3
    );
    PORT( 
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        startCounter : IN     std_ulogic;
        unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        done         : OUT    std_ulogic
    );

-- Declarations

END unitCounter ;





library Common;
  use Common.CommonLib.all;

ARCHITECTURE studentVersion OF unitCounter IS

  signal unitCounter: unsigned(requiredBitNb(unitCountDivide)-1 downto 0);
  signal unitCountDone: std_ulogic;
  signal unitNbCounter: unsigned(unitnB'range);
  signal unitNbCountDone: std_ulogic;

BEGIN
                                                       -- count unit base period
  countUnitDuration: process(reset, clock)
  begin
    if reset = '1' then
      unitCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitCounter = 0 then
        if (startCounter = '1') or (unitNbCounter > 0) then
          unitCounter <= unitCounter + 1;
        end if;
      else
        if unitCountDone = '0' then
          unitCounter <= unitCounter + 1;
        else
          unitCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countUnitDuration;

  unitCountDone <= '1' when unitCounter = unitCountDivide
    else '0';
                                                     -- count unit period number
  countPeriods: process(reset, clock)
  begin
    if reset = '1' then
      unitNbCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitNbCounter = 0 then
        if startCounter = '1' then
          unitNbCounter <= unitNbCounter + 1;
        end if;
      else
        if unitNbCountDone = '0' then
          if unitCountDone = '1' then
            unitNbCounter <= unitNbCounter + 1;
          end if;
        else
          unitNbCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countPeriods;

  unitNbCountDone <= '1' when (unitNbCounter = unitNb) and (unitCountDone = '1')
    else '0';

  done <= unitNbCountDone;

END ARCHITECTURE studentVersion;




-- VHDL Entity Morse.charToMorseController.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY charToMorseController IS
    GENERIC( 
        characterBitNb : positive := 8;
        unitCountBitNb : positive := 3
    );
    PORT( 
        morseOut     : OUT    std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        charNotReady : IN     std_ulogic;
        char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        startCounter : OUT    std_ulogic;
        unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        counterDone  : IN     std_ulogic;
        readChar     : OUT    std_ulogic
    );

-- Declarations

END charToMorseController ;





ARCHITECTURE studentVersion OF charToMorseController IS

  signal isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP,
         isQ, isR, isS, isT, isU, isV, isW, isX,
         isY, isZ,
         is0, is1, is2, is3, is4, is5, is6, is7,
         is8, is9 : std_ulogic;

type stateDote is (waitStartDot, sendDotStart, sendDotWait, sendDotSpacerStart, 
	sendDotSpacerWait, EndDot); 
type stateDash is (waitStartDash, sendDashStart, sendDashWait, sendDashSpacerStart, 
	sendDashSpacerWait, EndDash);
type stateChar is (waitForChar, storeChar, waitWordChar, waitWordCharSpacer, getNextChar,
	sendDot1, sendDash1, 
	sendDotWaitDot2, sendDotDot2, sendDotDash2, sendDashDot2, sendDashWaitDash2, sendDashDash2, 
	sendDotDotWaitDot3, sendDotDotDot3, sendDotDotDash3, sendDotDashDot3, sendDotDashWaitDash3, sendDotDashDash3, 
	sendDashDotWaitDot3, sendDashDotDot3, sendDashDotDash3, sendDashDashDot3, sendDashDashWaitDash3, sendDashDashDash3, 
	
	sendDotDotDotWaitDot4, sendDotDotDotDot4, sendDotDotDotDash4, 
	sendDotDotDashDot4, sendDotDotDashWaitDash4, sendDotDotDashDash4,
	sendDotDashDotWaitDot4, sendDotDashDotDot4,  
	
	sendDotDashDashDot4, sendDotDashDashWaitDash4, sendDotDashDashDash4,
	sendDashDotDotWaitDot4, sendDashDotDotDot4, sendDashDotDotDash4,
	sendDashDotDashDot4, sendDashDotDashWaitDash4, sendDashDotDashDash4,
	sendDashDashDotWaitDot4, sendDashDashDotDot4, sendDashDashDotDash4,
	sendDashDashDashDot4, sendDashDashDashWaitDash4, sendDashDashDashDash4,
	
	sendDotDotDotDotWaitDot5, sendDotDotDotDotDot5, 
	sendDotDotDotDotDash5,
	sendDotDotDotDashWaitDash5, sendDotDotDotDashDash5,
	sendDotDotDashDashWaitDash5, sendDotDotDashDashDash5,
	sendDashDotDotDotWaitDot5, sendDashDotDotDotDot5,
	sendDashDashDotDotWaitDot5, sendDashDashDotDotDot5,
	sendDashDashDashDotWaitDot5, sendDashDashDashDotDot5,
	sendDotDashDashDashWaitDash5, sendDotDashDashDashDash5,
	sendDashDashDashDashDot5,
	sendDashDashDashDashWaitDash5, sendDashDashDashDashDash5,
	
	
	endOfChar, sendSpacerWaitChar);

constant dotTime : positive := 1;
signal morseOutDot, strtCnterDot, dotSMActive, morseOutDash, strtCnterDash, dashSMActive, morseOutChar, strtCnterChar, charSMActive, sendDt, sendDs, rdChr : std_ulogic := '0';
signal unitNbDot, unitNbChar, unitNbDash : unsigned(unitNb'range) := to_unsigned(0, unitNb'length);
signal presentDot, nextDot : stateDote;
signal presentDash, nextDash : stateDash;
signal presentChar, nextChar : stateChar;

--Additionnal Inputs
signal sendDot, sendDash : std_ulogic;

--Additionnal outputs
signal dotSent, dashSent : std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
  --------------------------- CHAR SENT STATE MACHINE --------------------------
  nxt_Charstate : process(presentChar,isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP, isQ, isR, isS, isT, isU, isV, 
		 isW, isX, isY, isZ, is0, is1, is2, is3, is4, is5, is6, is7, is8, is9, 
		 charNotReady, counterDone, dashSent, dotSent)
	BEGIN
		case presentChar is
		
			-- Beginning of coding of a letter
			when waitForChar =>
				if charNotReady = '0' then 
					nextChar <= storeChar;
				else
					nextChar <= waitForChar;
				end if;
			when storeChar =>
				if (isA or isE or isF or isH or isI or isJ or isL or isP or isR 
				or isS or isU or isV or isW or is1 or is2 or is3 or is4 or is5) = '1' then 
					nextChar <= sendDot1;
				elsif (isB or isC or isD or isG or isK or isM or isN or isO or isQ
				or isT or isX or isY or isZ or is0 or is6 or is7 or is8 or is9) = '1' then
					nextChar <= sendDash1;
				else
					nextChar <= waitWordChar;
				end if;

			--Beginning of 1st Character : -
			when sendDot1 =>
				if dotSent = '1' then
					if (isF or isH or isI or isS or isU or isV or is2 or is3 or 
					is4 or is5) = '1' then
						nextChar <= sendDotWaitDot2;
					elsif (isA or isJ or isL or isP or isR or isW or is1) = '1' then
						nextChar <= sendDotDash2;
					else --char is e
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDot1;
				end if;
			when sendDash1 =>
				if dashSent = '1' then
					if (isB or isC or isD or isK or isN or isX or isY 
					or is6) = '1' then
						nextChar <= sendDashDot2;
					elsif (isG or isM or isO or isQ or isZ or is7 or is8 
					or is9 or is0) = '1' then
						nextChar <= sendDashWaitDash2;
					else --char is t
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDash1;
				end if;
				
			-- Beginning of 2nd Character : -/-
			when sendDotWaitDot2 =>
				nextChar <= sendDotDot2;
			when sendDotDot2 =>
				if dotSent = '1' then
					if (isH or isS or isV or is3 or is4 or is5) = '1' then
						nextChar <= sendDotDotWaitDot3;
					elsif (isF or isU or is2) = '1' then
						nextChar <= sendDotDotDash3;
					else --char is i
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDot2;
				end if;
			when sendDotDash2 =>
				if dashSent = '1' then
					if  (isL or  isR) = '1' then
						nextChar <= sendDotDashDot3;
					elsif (isJ or isP or isW or is1) = '1' then
						nextChar <= sendDotDashWaitDash3;
					else -- char is a
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDash2;
				end if;
			when sendDashDot2 =>
				if dotSent = '1' then
					if (isB or isD or isX or is6) = '1' then
						nextChar <= sendDashDotWaitDot3;
					elsif (isC or isK or isY) = '1' then
						nextChar <= sendDashDotDash3;
					else -- char is n 
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDot2;
				end if;
			when sendDashWaitDash2 =>
				nextChar <= sendDashDash2;
			when sendDashDash2 =>
				if dashSent = '1' then
					if (isG or isQ or isZ or is7) = '1' then
						nextChar <= sendDashDashDot3;
					elsif (isO or is8 or is9 or is0) = '1' then
						nextChar <= sendDashDashWaitDash3;
					else -- char is m
						nextChar <= endOfChar;
					end if;
				else
					nextChar <=  sendDashDash2;
				end if;
			-- End of 2nd Character : -/-	
			
			-- Beginning of 3rd Character: -/-/-
			when sendDotDotWaitDot3 =>
				nextChar <= sendDotDotDot3;
			when sendDotDotDot3 =>
				if dotSent = '1' then
					if (isH or is4 or is5) = '1' then
						nextChar <= sendDotDotDotWaitDot4;
					elsif (isV or is3) = '1' then
						nextChar <= sendDotDotDotDash4;
					else -- char is s
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDotDot3;
				end if;
			when sendDotDotDash3 =>
				if dashSent = '1' then
					if isF = '1' then
						nextChar <= sendDotDotDashDot4;
					elsif is2 = '1' then
						nextChar <= sendDotDotDashWaitDash4;
					else -- char is u
						nextChar <= endOfChar; 
					end if;
				else 
					nextChar <= sendDotDotDash3;
				end if;
			when sendDotDashDot3 =>
				if dotSent = '1' then
					if isL = '1'then
						nextChar <= sendDotDashDotWaitDot4;
					else -- char is r
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDashDot3;
				end if;
			when sendDotDashWaitDash3 =>
				nextChar <= sendDotDashDash3;
			when sendDotDashDash3 =>
				if dashSent = '1' then
					if isP = '1' then
						nextChar <= sendDotDashDashDot4;
					elsif (isJ or is1) = '1' then
						nextChar <= sendDotDashDashWaitDash4;
					else -- char is w
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDashDash3;
				end if;
			when sendDashDotWaitDot3 =>
				nextChar <= sendDashDotDot3;
			when sendDashDotDot3 =>
				if dotSent = '1' then
					if (isB or is6) = '1'  then
						nextChar <= sendDashDotDotWaitDot4;
					elsif isX = '1' then
						nextChar <= sendDashDotDotDash4;
					else -- char is d
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDotDot3;
				end if;
			when sendDashDotDash3 =>
				if dashSent = '1' then
					if isC = '1' then
						nextChar <= sendDashDotDashDot4;
					elsif isY = '1' then
						nextChar <= sendDashDotDashWaitDash4;
					else -- char is k
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDotDash3;
				end if;
			when sendDashDashDot3 =>
				if dotSent = '1' then
					if (isZ or is7) = '1' then
						nextChar <= sendDashDashDotWaitDot4; --z or 7 
					elsif isQ = '1' then
						nextChar <= sendDashDashDotDash4; -- q then end 
					else -- char is g
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDashDot3;
				end if;
			when sendDashDashWaitDash3 =>
				nextChar <= sendDashDashDash3;
			when sendDashDashDash3 =>
				if dashSent = '1' then
					if is8 = '1' then
						nextChar <= sendDashDashDashDot4;
					elsif (is0 or is9) = '1' then
						nextChar <= sendDashDashDashWaitDash4;
					else -- char is o
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDashDash3;
				end if;
			-- END of 3rd Character : -/-/-
			
			-- Beginning of 4th Character : -/-/-/-
				-- Beginning of 4th Character : -/-/-/Dot
			when sendDotDotDotWaitDot4 =>  
				nextChar <=  sendDotDotDotDot4;
			when sendDotDotDotDot4 =>
				if dotSent = '1' then
					if is5 = '1' then
						nextChar <= sendDotDotDotDotWaitDot5;
					elsif is4 = '1' then
						nextChar <= sendDotDotDotDotDash5;
					else 
						nextChar <= endOfChar; -- char is h 
					end if;
				else
					nextChar <= sendDotDotDotDot4;
				end if;
			when sendDotDotDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is f
				else
					nextChar <= sendDotDotDashDot4;
				end if;
			when sendDotDashDotWaitDot4 => nextChar <= sendDotDashDotDot4; 
			when sendDotDashDotDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is l
				else
					nextChar <= sendDotDashDotDot4;
				end if;
			when sendDotDashDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is p
				else
					nextChar <= sendDotDashDashDot4;
				end if;
			when sendDashDotDotWaitDot4 =>  
				nextChar <=  sendDashDotDotDot4;
			when sendDashDotDotDot4 =>
				if dotSent = '1' then
					if is6 = '1' then
						nextChar <= sendDashDotDotDotWaitDot5; 
					else
						nextChar <= endOfChar; --char is b 
					end if;
				else
					nextChar <= sendDashDotDotDot4;
				end if;
			when sendDashDotDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; -- char is c 
				else
					nextChar <= sendDashDotDashDot4;
				end if;
			when sendDashDashDashDot4 => 
				if dotSent = '1' then
					nextChar <= sendDashDashDashDotWaitDot5;
				else
					nextChar <= sendDashDashDashDot4;
				end if;
			when sendDashDashDotWaitDot4 =>  
				nextChar <=  sendDashDashDotDot4;
			when sendDashDashDotDot4 => 
				if dotSent = '1' then
					if is7 = '1' then
						nextChar <= sendDashDashDotDotWaitDot5;
					else
						nextChar <= endOfChar; -- char is z
					end if;
				else
					nextChar <= sendDashDashDotDot4;
				end if;
				
				-- Beginning of 4th Character : -/-/-/Dash
			when sendDotDotDotDash4 => 
				if dashSent = '1' then
					if is3 = '1' then
						nextChar <= sendDotDotDotDashWaitDash5;
					else 
						nextChar <= endOfChar; -- char is v
					end if;
				else
					nextChar <= sendDotDotDotDash4;
				end if;
			when sendDotDotDashWaitDash4 =>  
				nextChar <=  sendDotDotDashDash4;
			when sendDotDotDashDash4 =>
				if dashSent = '1' then
					nextChar <= sendDotDotDashDashWaitDash5;
				else
					nextChar <= sendDotDotDashDash4;
				end if;
			when sendDotDashDashWaitDash4 =>  nextChar <=  sendDotDashDashDash4;
			when sendDotDashDashDash4 =>
				if dashSent = '1' then
					if is1 = '1' then
						nextChar <= sendDotDashDashDashWaitDash5; 
					else
						nextChar <= endOfChar; -- char is j
					end if;
				else
					nextChar <= sendDotDashDashDash4;
				end if;
			when sendDashDotDotDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is x
				else
					nextChar <= sendDashDotDotDash4;
				end if;
			when sendDashDotDashWaitDash4 =>  
				nextChar <=  sendDashDotDashDash4;
			when sendDashDotDashDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is y
				else
					nextChar <= sendDashDotDashDash4;
				end if;
			when sendDashDashDotDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is q
				else
					nextChar <= sendDashDashDotDash4;
				end if;
			when sendDashDashDashWaitDash4 =>  
				nextChar <=  sendDashDashDashDash4;
			when sendDashDashDashDash4 => 
				if dashSent = '1' then
					if is9 = '1' then
						nextChar <= sendDashDashDashDashDot5;
					elsif is0 = '1' then
						nextChar <= sendDashDashDashDashWaitDash5;
					end if;
				else
					nextChar <= sendDashDashDashDash4;
				end if;
				-- End of 4th Character : -/-/-/Dash
			-- End of 4th Character : -/-/-/-
			
			-- Beginning of 5th Character : -/-/-/-/-
			when sendDotDotDotDotWaitDot5 => 
				nextChar <= sendDotDotDotDotDot5; 
			when sendDotDotDotDotDot5 =>  
				if dotSent = '1' then 
					nextChar <=  endOfChar; --char is 5
				else
					nextChar <= sendDotDotDotDotDot5 ;
				end if;
			when sendDotDotDotDotDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; --char is 4
				else
					nextChar <= sendDotDotDotDotDash5 ;
				end if;
			when sendDashDotDotDotWaitDot5 => 
				nextChar <= sendDashDotDotDotDot5;
			when sendDashDotDotDotDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar;  -- char is 6
				else
					nextChar <= sendDashDotDotDotDot5;
				end if;
			when sendDashDashDotDotWaitDot5 => 
				nextChar <= sendDashDashDotDotDot5;
			when sendDashDashDotDotDot5 => 
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 7
				else
					nextChar <= sendDashDashDotDotDot5;
				end if;
			when sendDotDotDotDashWaitDash5 => 
				nextChar <= sendDotDotDotDashDash5;
			when sendDotDotDotDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar;--char is 3
				else
					nextChar <= sendDotDotDotDashDash5;
				end if;
			when sendDotDotDashDashWaitDash5 => 
				nextChar <= sendDotDotDashDashDash5;
			when sendDotDotDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 2
				else
					nextChar <= sendDotDotDashDashDash5;
				end if;
			when sendDotDashDashDashWaitDash5 => 
				nextChar <= sendDotDashDashDashDash5;
			when sendDotDashDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 1
				else
					nextChar <= sendDotDashDashDashDash5;
				end if;
			when sendDashDashDashDotWaitDot5 => 
				nextChar <= sendDashDashDashDotDot5;
			when sendDashDashDashDotDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 8
				else
					nextChar <= sendDashDashDashDotDot5;
				end if;
			when sendDashDashDashDashDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 9
				else
					nextChar <= sendDashDashDashDashDot5;
				end if;
			when sendDashDashDashDashWaitDash5 => 
				nextChar <= sendDashDashDashDashDash5;
			when sendDashDashDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 0  
				else
					nextChar <= sendDashDashDashDashDash5;
				end if;
			-- End of 5th Character : -/-/-/-/-
			
			
			
			-- End of coding of a letter
			when waitWordChar =>
				nextChar <= waitWordCharSpacer;
			when waitWordCharSpacer =>
				if counterDone = '1' then
					nextChar <= endOfChar;
				else
					nextChar <= waitWordCharSpacer;
				end if;
			when endOfChar =>
				nextChar <= sendSpacerWaitChar;
			when sendSpacerWaitChar =>
				if counterDone = '1' then 
					nextChar <= getNextChar;
				else
					nextChar <= sendSpacerWaitChar;
				end if;
			when getNextChar =>
				nextChar <= waitForChar;
			when others =>
				nextChar <= waitForChar; 
		end case;
	end process;
	
	-- CHAR SENT STATE MACHINE
	state_Char_reg : process(clock,reset)
	BEGIN
		if reset = '1' then
			presentChar <= waitForChar;
		elsif rising_edge(clock) then
			presentChar <= nextChar;
		end if;
	end process;
	
	
	-- OUTPUT : 
	outputChar : process(presentChar)
	BEGIN
		case presentChar is
			when waitForChar =>
				charSMActive <= '0';
				sendDs <= '0';
				sendDt <= '0';
				morseOutChar <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				strtCnterChar <= '0';
				rdChr <= '0';
			when storeChar =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDot1 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDash1 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDotDot2 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDash2 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDot2 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDash2 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDotDotDot3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDash3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDot3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDash3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDashDotDot3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDash3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDot3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDash3 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDotDot4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDotDash4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDashDot4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDashDash4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDotDot4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDashDot4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDashDash4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDotDot4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDotDash4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDashDot4 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDashDash4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDotDot4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDotDash4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDashDot4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDashDash4 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDotDotDot5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDotDotDash5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDotDashDash5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDotDashDashDash5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDotDotDotDot5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDotDotDot5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDashDotDot5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDotDashDashDashDash5 =>
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDashDashDot5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0'; 
				sendDt <= '1';
				strtCnterChar <= '0';
				rdChr <= '0';
			when sendDashDashDashDashDash5 => 
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '1'; 
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			-- CHAR SENT STATE MACHINE
			when waitWordChar =>
				morseOutChar <= '0';
				charSMActive <= '1';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '1';
				rdChr <= '0';
			when waitWordCharSpacer =>
				charSMActive <= '1';
				unitNbChar <= to_unsigned(2*dotTime, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when endOfChar =>
				morseOutChar <= '0';
				charSMActive <= '1';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '1';
				rdChr <= '0';
			when sendSpacerWaitChar =>
				charSMActive <= '1';
				unitNbChar <= to_unsigned(2*dotTime, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when getNextChar =>
				morseOutChar <= '0';
				charSMActive <= '1';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '1';
			when others =>
				morseOutChar <= '0';
				charSMActive <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			end case;
	end process;
  
  --------------------------- END CHAR SENT STATE MACHINE ----------------------
  
  
  --------------------------- DOT SENT STATE MACHINE ---------------------------
	nxt_Dotstate : process(presentDot,sendDot, counterDone)
	BEGIN
		case presentDot is
			when waitStartDot =>
				if sendDot = '1' then 
					nextDot <= sendDotStart;
				else
					nextDot <= waitStartDot;
				end if;
			when sendDotStart =>
				nextDot <= sendDotWait;
			when sendDotWait =>
				if counterDone = '1' then
					nextDot <= sendDotSpacerStart;
				else
					nextDot <= sendDotWait;
				end if;
			when sendDotSpacerStart =>
				nextDot <= sendDotSpacerWait;
			when sendDotSpacerWait =>
				if counterDone = '1' then
					nextDot <= EndDot;
				else
					nextDot <= sendDotSpacerWait;
				end if;
			when endDot =>
				nextDot <= waitStartDot;
			when others =>
				nextDot <= waitStartDot; 
		end case;
	end process;
	
	state_Dot_reg : process(clock,reset)
	BEGIN
		if reset = '1' then
			presentDot <= waitStartDot;
			
		elsif rising_edge(clock) then
			presentDot <= nextDot;
		end if;
	end process;
	
	
	-- OUTPUT : morseOut, unitNb, dotSent,startCounter
	outputDot : process(presentDot)
	BEGIN
		case presentDot is
			when waitStartDot =>
				morseOutDot <= '0';
				dotSMActive <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when sendDotStart =>
				morseOutDot <= '0';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '1';
			when sendDotWait =>
				morseOutDot <= '1';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(dotTime, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when sendDotSpacerStart =>
				morseOutDot <= '0';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '1';
			when sendDotSpacerWait =>
				morseOutDot <= '0';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(dotTime, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when endDot =>
				morseOutDot <= '0';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '1';
				strtCnterDot <= '0';
				--sendDt <= '0';
			when others =>
				morseOutDot <= '0';
				dotSMActive <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
		end case;
	end process;
		
------------------------- END DOT SENT STATE MACHINE --------------------------		

--------------------------- DASH SENT STATE MACHINE ---------------------------
	nxt_Dashstate : process(presentDash,sendDash, counterDone)
	BEGIN
		case presentDash is
			when waitStartDash =>
				if sendDash = '1' then 
					nextDash <= sendDashStart;
				else
					nextDash <= waitStartDash;
				end if;
			when sendDashStart =>
				nextDash <= sendDashWait;
			when sendDashWait =>
				if counterDone = '1' then
					nextDash <= sendDashSpacerStart;
				else
					nextDash <= sendDashWait;
				end if;
			when sendDashSpacerStart =>
				nextDash <= sendDashSpacerWait;
			when sendDashSpacerWait =>
				if counterDone = '1' then
					nextDash <= EndDash;
				else
					nextDash <= sendDashSpacerWait;
				end if;
			when endDash =>
				nextDash <= waitStartDash;
			when others =>
				nextDash <= waitStartDash; 
		end case;
	end process;
	
	state_Dashreg : process(clock,reset)
		BEGIN
		if reset = '1' then
			presentDash <= waitStartDash;
		elsif rising_edge(clock) then
			presentDash <= nextDash;
		end if;
	end process;
	
	
	-- OUTPUT : morseOut, unitNb, dashSent,startCounter
	outputDash : process(presentDash)
	BEGIN
		case presentDash is
			when waitStartDash =>
				morseOutDash <= '0';
				dashSMActive <= '0';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when sendDashStart =>
				morseOutDash <= '0';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '1';
			when sendDashWait =>
				morseOutDash <= '1';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(3*dotTime, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when sendDashSpacerStart =>
				morseOutDash <= '0';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '1';
			when sendDashSpacerWait =>
				morseOutDash <= '0';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(dotTime, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when endDash =>
				morseOutDash <= '0';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '1';
				strtCnterDash <= '0';
				--sendDash <= '0';
			when others =>
				dashSMActive <= '0';
				morseOutDash <= '0';
				unitNbDash <=to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
		end case;
	end process;
------------------------- END DASH SENT STATE MACHINE --------------------------			
			


  ------------------------------------------------------------------------------
                                                   -- conditions for morse units
  isA <= '1' when std_match(unsigned(char), "1-0" & x"1") else '0';
  isB <= '1' when std_match(unsigned(char), "1-0" & x"2") else '0';
  isC <= '1' when std_match(unsigned(char), "1-0" & x"3") else '0';
  isD <= '1' when std_match(unsigned(char), "1-0" & x"4") else '0';
  isE <= '1' when std_match(unsigned(char), "1-0" & x"5") else '0';
  isF <= '1' when std_match(unsigned(char), "1-0" & x"6") else '0';
  isG <= '1' when std_match(unsigned(char), "1-0" & x"7") else '0';
  isH <= '1' when std_match(unsigned(char), "1-0" & x"8") else '0';
  isI <= '1' when std_match(unsigned(char), "1-0" & x"9") else '0';
  isJ <= '1' when std_match(unsigned(char), "1-0" & x"A") else '0';
  isK <= '1' when std_match(unsigned(char), "1-0" & x"B") else '0';
  isL <= '1' when std_match(unsigned(char), "1-0" & x"C") else '0';
  isM <= '1' when std_match(unsigned(char), "1-0" & x"D") else '0';
  isN <= '1' when std_match(unsigned(char), "1-0" & x"E") else '0';
  isO <= '1' when std_match(unsigned(char), "1-0" & x"F") else '0';
  isP <= '1' when std_match(unsigned(char), "1-1" & x"0") else '0';
  isQ <= '1' when std_match(unsigned(char), "1-1" & x"1") else '0';
  isR <= '1' when std_match(unsigned(char), "1-1" & x"2") else '0';
  isS <= '1' when std_match(unsigned(char), "1-1" & x"3") else '0';
  isT <= '1' when std_match(unsigned(char), "1-1" & x"4") else '0';
  isU <= '1' when std_match(unsigned(char), "1-1" & x"5") else '0';
  isV <= '1' when std_match(unsigned(char), "1-1" & x"6") else '0';
  isW <= '1' when std_match(unsigned(char), "1-1" & x"7") else '0';
  isX <= '1' when std_match(unsigned(char), "1-1" & x"8") else '0';
  isY <= '1' when std_match(unsigned(char), "1-1" & x"9") else '0';
  isZ <= '1' when std_match(unsigned(char), "1-1" & x"A") else '0';
  is0 <= '1' when std_match(unsigned(char), "011" & x"0") else '0';
  is1 <= '1' when std_match(unsigned(char), "011" & x"1") else '0';
  is2 <= '1' when std_match(unsigned(char), "011" & x"2") else '0';
  is3 <= '1' when std_match(unsigned(char), "011" & x"3") else '0';
  is4 <= '1' when std_match(unsigned(char), "011" & x"4") else '0';
  is5 <= '1' when std_match(unsigned(char), "011" & x"5") else '0';
  is6 <= '1' when std_match(unsigned(char), "011" & x"6") else '0';
  is7 <= '1' when std_match(unsigned(char), "011" & x"7") else '0';
  is8 <= '1' when std_match(unsigned(char), "011" & x"8") else '0';
  is9 <= '1' when std_match(unsigned(char), "011" & x"9") else '0';
  
  sendDot <= sendDt;
  sendDash <= sendDs;
  
  morseOut <= morseOutDash when dashSMActive = '1' else morseOutDot when dotSMActive = '1' else morseOutChar when charSMActive = '1' else '0';
  startCounter <= strtCnterDot when dotSMActive = '1' else strtCnterDash when dashSMActive = '1' else strtCnterChar when charSMActive = '1' else '0';
  readChar <= rdChr;
  unitNb <= unitNbDot when dotSMActive = '1' else unitNbDash when dashSMActive = '1' else unitNbChar when charSMActive = '1' else to_unsigned(0, unitNb'length);

END ARCHITECTURE studentVersion;




--
-- VHDL Architecture Morse.charToMorse.struct
--
-- Created:
--          by - julien.chevalle1.UNKNOWN (WE2330802)
--          at - 14:20:44 12.04.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Morse;

ARCHITECTURE struct OF charToMorse IS

    -- Architecture declarations
    constant unitCountBitNb: positive := 3;

    -- Internal signal declarations
    SIGNAL startCounter : std_ulogic;
    SIGNAL done         : std_ulogic;
    SIGNAL unitNb       : unsigned(unitCountBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT charToMorseController
    GENERIC (
        characterBitNb : positive := 8;
        unitCountBitNb : positive := 3
    );
    PORT (
        morseOut     : OUT    std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        charNotReady : IN     std_ulogic ;
        char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        startCounter : OUT    std_ulogic ;
        unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        counterDone  : IN     std_ulogic ;
        readChar     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT unitCounter
    GENERIC (
        unitCountDivide : positive := 10E3;
        unitCountBitNb  : positive := 3
    );
    PORT (
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        startCounter : IN     std_ulogic ;
        unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        done         : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : charToMorseController USE ENTITY Morse.charToMorseController;
    FOR ALL : unitCounter USE ENTITY Morse.unitCounter;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_ctl : charToMorseController
        GENERIC MAP (
            characterBitNb => characterBitNb,
            unitCountBitNb => unitCountBitNb
        )
        PORT MAP (
            morseOut     => morseOut,
            clock        => clock,
            reset        => reset,
            charNotReady => charNotReady,
            char         => charIn,
            startCounter => startCounter,
            unitNb       => unitNb,
            counterDone  => done,
            readChar     => readChar
        );
    I_cnt : unitCounter
        GENERIC MAP (
            unitCountDivide => unitCountDivide,
            unitCountBitNb  => unitCountBitNb
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            startCounter => startCounter,
            unitNb       => unitNb,
            done         => done
        );

END struct;




-- VHDL Entity Morse.toneGenerator.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY toneGenerator IS
    GENERIC( 
        toneDivide : positive := 100E3
    );
    PORT( 
        tone  : OUT    std_ulogic;
        clock : IN     std_ulogic;
        reset : IN     std_ulogic
    );

-- Declarations

END toneGenerator ;





library Common;
  use Common.CommonLib.all;

ARCHITECTURE studentVersion OF toneGenerator IS

  constant toneCounterBitNb: positive := requiredBitNb(toneDivide-1);
  signal toneCounter: unsigned(toneCounterBitNb-1 downto 0);
  constant toneMin : natural := (2**toneCounterBitNb - toneDivide) / 2;
  constant toneMax : natural := toneMin + toneDivide;

BEGIN

  divide: process(reset, clock)
  begin
    if reset = '1' then
      toneCounter <= to_unsigned(toneMin, toneCounter'length);
    elsif rising_edge(clock) then
      if toneCounter = toneMax then
        toneCounter <= to_unsigned(toneMin, toneCounter'length);
      else
        toneCounter <= toneCounter + 1;
      end if;
    end if;
  end process divide;

  tone <= toneCounter(toneCounter'high);

END ARCHITECTURE studentVersion;




-- VHDL Entity RS232.serialPortReceiver.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortReceiver IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        RxD       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic
    );

-- Declarations

END serialPortReceiver ;





--===========================================================================--
--  Design units : CoCa.serialPortReceiver.rtl
--
--  File name : serialPortReceiver_rtl.vhd
--
--  Purpose : Decode data from UART into words
--
--  Input : serial line data
--
--  Output : 
--      dataOut : word of data
--      dataValid : active when a new word of data is available
--
--
--  Limitations : 
--  
--  
--
--  Errors: : None known
--
--  Library : Common
--
--  Dependencies : None
--
--  Author : 
--  Haute école d'ingénierie (HEI/HES-SO)
--  Institut systèmes industriels (ISI)
--  Rue de l'industrie 23
--  1950 Sion
--  Switzerland (CH)
--
--  Simulator : Mentor ModelSim V10.7c
------------------------------------------------
--  Revision list
--  Version Author Date Changes
--
--  V1.0 04.04.2022 - First version
--===========================================================================--

library Common;
  use Common.CommonLib.all;

architecture RTL of serialPortReceiver is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(dataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(dataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset and not dividerCounterSynchronize;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = dataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  dataOut <= rxShiftReg;
  dataValid <= rxDataValid;

end RTL;





--
-- VHDL Architecture Morse.morseEncoder.struct
--
-- Created:
--          by - julien.chevalle1.UNKNOWN (WE2330802)
--          at - 13:44:04 10.04.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Memory;
LIBRARY Morse;
LIBRARY RS232;

ARCHITECTURE struct OF morseEncoder IS

    -- Architecture declarations
    constant fifoDepth : positive := 100;

    -- Internal signal declarations
    SIGNAL characterReg   : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL characterIn    : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL characterValid : std_ulogic;
    SIGNAL morseOut       : std_ulogic;
    SIGNAL tone           : std_ulogic;
    SIGNAL charNotReady   : std_ulogic;
    SIGNAL readChar       : std_ulogic;


    -- Component Declarations
    COMPONENT FIFO_bram
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT charToMorse
    GENERIC (
        characterBitNb  : positive := 8;
        unitCountDivide : positive := 10E3
    );
    PORT (
        morseOut     : OUT    std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        charIn       : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        readChar     : OUT    std_ulogic ;
        charNotReady : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT toneGenerator
    GENERIC (
        toneDivide : positive := 100E3
    );
    PORT (
        tone  : OUT    std_ulogic ;
        clock : IN     std_ulogic ;
        reset : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortReceiver
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        RxD       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
    FOR ALL : charToMorse USE ENTITY Morse.charToMorse;
    FOR ALL : serialPortReceiver USE ENTITY RS232.serialPortReceiver;
    FOR ALL : toneGenerator USE ENTITY Morse.toneGenerator;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    morseCode <= morseOut and tone;


    -- Instance port mappings.
    I_FIFO : FIFO_bram
        GENERIC MAP (
            dataBitNb => uartDataBitNb,
            depth     => fifoDepth
        )
        PORT MAP (
            write   => characterValid,
            clock   => clock,
            reset   => reset,
            dataOut => characterReg,
            read    => readChar,
            dataIn  => characterIn,
            empty   => charNotReady,
            full    => OPEN
        );
    I_enc : charToMorse
        GENERIC MAP (
            characterBitNb  => uartDataBitNb,
            unitCountDivide => integer(clockFrequency*unitDuration + 0.5)
        )
        PORT MAP (
            morseOut     => morseOut,
            clock        => clock,
            reset        => reset,
            charNotReady => charNotReady,
            charIn       => characterReg,
            readChar     => readChar
        );
    I_tone : toneGenerator
        GENERIC MAP (
            toneDivide => integer(clockFrequency/toneFrequency + 0.5)
        )
        PORT MAP (
            tone  => tone,
            clock => clock,
            reset => reset
        );
    I_UART : serialPortReceiver
        GENERIC MAP (
            dataBitNb      => uartDataBitNb,
            baudRateDivide => integer(clockFrequency/uartBaudRate + 0.5)
        )
        PORT MAP (
            RxD       => RxD,
            clock     => clock,
            reset     => reset,
            dataOut   => characterIn,
            dataValid => characterValid
        );

END struct;




--
-- VHDL Architecture Board.morse_ebs2.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:49:40 28.04.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Board;
LIBRARY Morse;

ARCHITECTURE struct OF morse_ebs2 IS

    -- Architecture declarations
    constant clockFrequency: real := 66.0E6;
    constant uartBaudRate: real := 9.6E3;
    constant uartDataBitNb: positive := 7;
    constant morseUnitDuration: real := 100.0E-3;  -- 1/2 * 10 Hz
    constant morseToneFrequency: real := 3135.96;  -- sol 3eme octave
    constant deglitchBitNb: positive := 16;

    -- Internal signal declarations
    SIGNAL logic1        : std_uLogic;
    SIGNAL morseIn_synch : std_uLogic;
    SIGNAL reset1        : std_ulogic;
    SIGNAL resetSnch_N1  : std_ulogic;
    SIGNAL resetSynch    : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL RxD_synch_internal : std_ulogic;


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverterIn
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT morseDecoder
    GENERIC (
        clockFrequency : real     := 100.0E6;
        uartBaudRate   : real     := 115.2E3;
        uartDataBitNb  : positive := 8;
        unitDuration   : real     := 100.0E-3;
        toneFrequency  : real     := 300.0;
        deglitchBitNb  : natural  := 8
    );
    PORT (
        morseCode     : IN     std_ulogic ;
        clock         : IN     std_ulogic ;
        reset         : IN     std_ulogic ;
        TxD           : OUT    std_ulogic ;
        morseEnvelope : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT morseEncoder
    GENERIC (
        clockFrequency : real     := 100.0E6;
        uartBaudRate   : real     := 115.2E3;
        uartDataBitNb  : positive := 8;
        unitDuration   : real     := 100.0E-3;
        toneFrequency  : real     := 300.0
    );
    PORT (
        morseCode : OUT    std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        RxD       : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : DFF USE ENTITY Board.DFF;
    FOR ALL : inverterIn USE ENTITY Board.inverterIn;
    FOR ALL : morseDecoder USE ENTITY Morse.morseDecoder;
    FOR ALL : morseEncoder USE ENTITY Morse.morseEncoder;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 5 eb5
    logic1 <= '1';


    -- Instance port mappings.
    I7 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => RxD,
            Q   => RxD_synch_internal
        );
    I8 : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset1,
            D   => logic1,
            Q   => resetSnch_N1
        );
    I9 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => morseIn,
            Q   => morseIn_synch
        );
    I3 : inverterIn
        PORT MAP (
            in1  => reset_N,
            out1 => reset1
        );
    I4 : inverterIn
        PORT MAP (
            in1  => resetSnch_N1,
            out1 => resetSynch
        );
    I_dec : morseDecoder
        GENERIC MAP (
            clockFrequency => clockFrequency,
            uartBaudRate   => uartBaudRate,
            uartDataBitNb  => uartDataBitNb,
            unitDuration   => morseUnitDuration,
            toneFrequency  => morseToneFrequency,
            deglitchBitNb  => deglitchBitNb
        )
        PORT MAP (
            morseCode     => morseIn_synch,
            clock         => clock,
            reset         => resetSynch,
            TxD           => TxD,
            morseEnvelope => morseEnvelope
        );
    I_enc : morseEncoder
        GENERIC MAP (
            clockFrequency => clockFrequency,
            uartBaudRate   => uartBaudRate,
            uartDataBitNb  => uartDataBitNb,
            unitDuration   => morseUnitDuration,
            toneFrequency  => morseToneFrequency
        )
        PORT MAP (
            morseCode => morseOut,
            clock     => clock,
            reset     => resetSynch,
            RxD       => RxD_synch_internal
        );

    -- Implicit buffered output assignments
    RxD_synch <= RxD_synch_internal;

END struct;




