--
-- VHDL Architecture SystemOnChip.beamerSoc.struct
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 15:02:29 28.04.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;
LIBRARY AhbLite;
  USE AhbLite.ahbLite.all;

LIBRARY AhbLiteComponents;
LIBRARY NanoBlaze;
LIBRARY SystemOnChip;

ARCHITECTURE struct OF beamerSoc IS

    -- Architecture declarations
    constant programCounterBitNb: positive := 10;
    constant instructionBitNb: positive := 26;
    constant stackPointerBitNb: positive := 4;
    constant registerAddressBitNb: positive := 4;
    constant scratchpadAddressBitNb: natural := 0;
    
    constant signalBitNb: positive := 16;
    constant updatePeriodBitNb : positive := 16;
    
    constant gpioIndex: positive := 1;
    constant uartIndex: positive := gpioIndex+1;
    constant beamerIndex: positive := uartIndex+1;
    
    constant ahbMemoryLocation : ahbMemoryLocationVector := (
      gpioIndex => (
        baseAddress => 16#0000#,
        addressMask => 16#10000# - 16#0002#
      ),
      uartIndex => (
        baseAddress => 16#0010#,
        addressMask => 16#10000# - 16#0004#
      ),
      beamerIndex => (
        baseAddress => 16#0020#,
        addressMask => 16#10000# - 16#0004#
      ),
      others => (
        baseAddress => 16#FFFF#,
        addressMask => 16#0000#
      )
    );

    -- Internal signal declarations
    SIGNAL upEn           : std_ulogic;
    SIGNAL int            : std_uLogic;
    SIGNAL upAddress      : unsigned(ahbAddressBitNb-1 DOWNTO 0);
    SIGNAL upDataOut      : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL upDataIn       : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL upReadStrobe   : std_uLogic;
    SIGNAL upWriteStrobe  : std_uLogic;
    SIGNAL hAddr          : unsigned(ahbAddressBitNb-1 DOWNTO 0);
    SIGNAL hWData         : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRData         : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hTrans         : std_ulogic_vector(ahbTransBitNb-1 DOWNTO 0);
    SIGNAL hSize          : std_ulogic_vector(ahbSizeBitNb-1 DOWNTO 0);
    SIGNAL hBurst         : std_ulogic_vector(ahbBurstBitNb-1 DOWNTO 0);
    SIGNAL hProt          : std_ulogic_vector(ahbProtBitNb-1 DOWNTO 0);
    SIGNAL hWrite         : std_uLogic;
    SIGNAL hReady         : std_uLogic;
    SIGNAL hMastLock      : std_uLogic;
    SIGNAL hResp          : std_uLogic;
    SIGNAL hClk           : std_uLogic;
    SIGNAL hReset_n       : std_uLogic;
    SIGNAL hSelV          : std_ulogic_vector(1 TO ahbSlaveNb);
    SIGNAL hRDataV        : ahbDataVector;
    SIGNAL hReadyV        : std_logic_vector(1 TO ahbSlaveNb);
    SIGNAL hRespV         : std_logic_vector(1 TO ahbSlaveNb);
    SIGNAL hSelGpio       : std_uLogic;
    SIGNAL hRespGpio      : std_uLogic;
    SIGNAL hReadyGpio     : std_uLogic;
    SIGNAL hRDataGpio     : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRDataBeamer   : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hRDataUart     : std_ulogic_vector(ahbDataBitNb-1 DOWNTO 0);
    SIGNAL hSelBeamer     : std_uLogic;
    SIGNAL hSelUart       : std_uLogic;
    SIGNAL hRespUart      : std_uLogic;
    SIGNAL hRespBeamer    : std_uLogic;
    SIGNAL hReadyBeamer   : std_uLogic;
    SIGNAL hReadyUart     : std_uLogic;
    SIGNAL intAck         : std_ulogic;
    SIGNAL instruction    : std_ulogic_vector(instructionBitNb-1 DOWNTO 0);
    SIGNAL programCounter : unsigned(programCounterBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT ahbDecoder
    GENERIC (
        ahbMemoryLocation : ahbMemoryLocationVector
    );
    PORT (
        hAddr : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hSel  : OUT    std_ulogic_vector (1 TO ahbSlaveNb)
    );
    END COMPONENT;
    COMPONENT ahbMasterInterface
    PORT (
        clock        : IN     std_ulogic ;
        hRData       : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady       : IN     std_uLogic ;
        hResp        : IN     std_uLogic ;
        pAddress     : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        pDataOut     : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        pReadStrobe  : IN     std_uLogic ;
        pWriteStrobe : IN     std_uLogic ;
        reset        : IN     std_ulogic ;
        hAddr        : OUT    unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hBurst       : OUT    std_ulogic_vector (ahbBurstBitNb-1 DOWNTO 0);
        hClk         : OUT    std_uLogic ;
        hMastLock    : OUT    std_uLogic ;
        hProt        : OUT    std_ulogic_vector (ahbProtBitNb-1 DOWNTO 0);
        hReset_n     : OUT    std_uLogic ;
        hSize        : OUT    std_ulogic_vector (ahbSizeBitNb-1 DOWNTO 0);
        hTrans       : OUT    std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData       : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite       : OUT    std_uLogic ;
        pDataIn      : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ahbMultiplexor
    PORT (
        hRDataV : IN     ahbDataVector ;
        hReadyV : IN     std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : IN     std_logic_vector (1 TO ahbSlaveNb);
        hSel    : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRData  : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : OUT    std_uLogic ;
        hResp   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbMuxConnector
    GENERIC (
        index : positive := 1
    );
    PORT (
        hRData  : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady  : IN     std_uLogic ;
        hResp   : IN     std_uLogic ;
        hSelV   : IN     std_ulogic_vector ( 1 TO ahbSlaveNb );
        hRDataV : OUT    ahbDataVector ;
        hReadyV : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hRespV  : OUT    std_logic_vector (1 TO ahbSlaveNb);
        hSel    : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbGpio
    GENERIC (
        ioNb : positive := 8
    );
    PORT (
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic ;
        hReset_n : IN     std_uLogic ;
        hSel     : IN     std_uLogic ;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic ;
        ioIn     : IN     std_ulogic_vector (ioNb-1 DOWNTO 0);
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic ;
        hResp    : OUT    std_uLogic ;
        ioEn     : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0);
        ioOut    : OUT    std_ulogic_vector (ioNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT ahbUart
    GENERIC (
        txFifoDepth : positive := 8;
        rxFifoDepth : positive := 1
    );
    PORT (
        RxD      : IN     std_ulogic ;
        hAddr    : IN     unsigned ( ahbAddressBitNb-1 DOWNTO 0 );
        hClk     : IN     std_uLogic ;
        hReset_n : IN     std_uLogic ;
        hSel     : IN     std_uLogic ;
        hTrans   : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWData   : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hWrite   : IN     std_uLogic ;
        TxD      : OUT    std_ulogic ;
        hRData   : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hReady   : OUT    std_uLogic ;
        hResp    : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT nanoProcessor
    GENERIC (
        addressBitNb           : positive := 8;
        registerBitNb          : positive := 8;
        registerAddressBitNb   : positive := 4;
        programCounterBitNb    : positive := 10;
        stackPointerBitNb      : positive := 5;
        instructionBitNb       : positive := 18;
        scratchpadAddressBitNb : natural  := 4
    );
    PORT (
        clock       : IN     std_ulogic ;
        dataIn      : IN     std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        en          : IN     std_ulogic ;
        instruction : IN     std_ulogic_vector (instructionBitNb-1 DOWNTO 0);
        int         : IN     std_uLogic ;
        reset       : IN     std_ulogic ;
        dataAddress : OUT    unsigned (addressBitNb-1 DOWNTO 0);
        dataOut     : OUT    std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        intAck      : OUT    std_ulogic ;
        progCounter : OUT    unsigned ( programCounterBitNb-1 DOWNTO 0 );
        readStrobe  : OUT    std_uLogic ;
        writeStrobe : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT ahbBeamer
    GENERIC (
        patternAddressBitNb : positive := 9;
        testOutBitNb        : positive := 16
    );
    PORT (
        outX      : OUT    std_ulogic ;
        hAddr     : IN     unsigned (ahbAddressBitNb-1 DOWNTO 0);
        outY      : OUT    std_ulogic ;
        hWData    : IN     std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        selSinCos : IN     std_ulogic ;
        testOut   : OUT    std_ulogic_vector (1 TO testOutBitNb);
        hRData    : OUT    std_ulogic_vector (ahbDataBitNb-1 DOWNTO 0);
        hTrans    : IN     std_ulogic_vector (ahbTransBitNb-1 DOWNTO 0);
        hWrite    : IN     std_ulogic ;
        hSel      : IN     std_ulogic ;
        hReady    : OUT    std_ulogic ;
        hResp     : OUT    std_ulogic ;
        hClk      : IN     std_ulogic ;
        hReset_n  : IN     std_ulogic 
    );
    END COMPONENT;
    COMPONENT programRom
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8
    );
    PORT (
        address : IN     unsigned (addressBitNb-1 DOWNTO 0);
        clock   : IN     std_ulogic ;
        en      : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector ( dataBitNb-1 DOWNTO 0 )
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : ahbBeamer USE ENTITY SystemOnChip.ahbBeamer;
    FOR ALL : ahbDecoder USE ENTITY AhbLite.ahbDecoder;
    FOR ALL : ahbGpio USE ENTITY AhbLiteComponents.ahbGpio;
    FOR ALL : ahbMasterInterface USE ENTITY AhbLite.ahbMasterInterface;
    FOR ALL : ahbMultiplexor USE ENTITY AhbLite.ahbMultiplexor;
    FOR ALL : ahbMuxConnector USE ENTITY AhbLite.ahbMuxConnector;
    FOR ALL : ahbUart USE ENTITY AhbLiteComponents.ahbUart;
    FOR ALL : nanoProcessor USE ENTITY NanoBlaze.nanoProcessor;
    FOR ALL : programRom USE ENTITY SystemOnChip.programRom;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    upEn <= '1';


    -- Instance port mappings.
    I_dec : ahbDecoder
        GENERIC MAP (
            ahbMemoryLocation => ahbMemoryLocation
        )
        PORT MAP (
            hAddr => hAddr,
            hSel  => hSelV
        );
    I_mst : ahbMasterInterface
        PORT MAP (
            clock        => clock,
            hRData       => hRData,
            hReady       => hReady,
            hResp        => hResp,
            pAddress     => upAddress,
            pDataOut     => upDataOut,
            pReadStrobe  => upReadStrobe,
            pWriteStrobe => upWriteStrobe,
            reset        => reset,
            hAddr        => hAddr,
            hBurst       => hBurst,
            hClk         => hClk,
            hMastLock    => hMastLock,
            hProt        => hProt,
            hReset_n     => hReset_n,
            hSize        => hSize,
            hTrans       => hTrans,
            hWData       => hWData,
            hWrite       => hWrite,
            pDataIn      => upDataIn
        );
    I_mux : ahbMultiplexor
        PORT MAP (
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelV,
            hRData  => hRData,
            hReady  => hReady,
            hResp   => hResp
        );
    I_connBeam : ahbMuxConnector
        GENERIC MAP (
            index => beamerIndex
        )
        PORT MAP (
            hRData  => hRDataBeamer,
            hReady  => hReadyBeamer,
            hResp   => hRespBeamer,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelBeamer
        );
    I_connT : ahbMuxConnector
        GENERIC MAP (
            index => gpioIndex
        )
        PORT MAP (
            hRData  => hRDataGpio,
            hReady  => hReadyGpio,
            hResp   => hRespGpio,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelGpio
        );
    I_connUart : ahbMuxConnector
        GENERIC MAP (
            index => uartIndex
        )
        PORT MAP (
            hRData  => hRDataUart,
            hReady  => hReadyUart,
            hResp   => hRespUart,
            hSelV   => hSelV,
            hRDataV => hRDataV,
            hReadyV => hReadyV,
            hRespV  => hRespV,
            hSel    => hSelUart
        );
    I_GPIO : ahbGpio
        GENERIC MAP (
            ioNb => ioNb
        )
        PORT MAP (
            hAddr    => hAddr,
            hClk     => hClk,
            hReset_n => hReset_n,
            hSel     => hSelGpio,
            hTrans   => hTrans,
            hWData   => hWData,
            hWrite   => hWrite,
            ioIn     => ioIn,
            hRData   => hRDataGpio,
            hReady   => hReadyGpio,
            hResp    => hRespGpio,
            ioEn     => ioEn,
            ioOut    => ioOut
        );
    I_UART : ahbUart
        GENERIC MAP (
            txFifoDepth => 8,
            rxFifoDepth => 1
        )
        PORT MAP (
            RxD      => RxD,
            hAddr    => hAddr,
            hClk     => hClk,
            hReset_n => hReset_n,
            hSel     => hSelUart,
            hTrans   => hTrans,
            hWData   => hWData,
            hWrite   => hWrite,
            TxD      => TxD,
            hRData   => hRDataUart,
            hReady   => hReadyUart,
            hResp    => hRespUart
        );
    I_up : nanoProcessor
        GENERIC MAP (
            addressBitNb           => ahbAddressBitNb,
            registerBitNb          => ahbDataBitNb,
            registerAddressBitNb   => registerAddressBitNb,
            programCounterBitNb    => programCounterBitNb,
            stackPointerBitNb      => stackPointerBitNb,
            instructionBitNb       => instructionBitNb,
            scratchpadAddressBitNb => scratchpadAddressBitNb
        )
        PORT MAP (
            clock       => clock,
            dataIn      => upDataIn,
            en          => upEn,
            instruction => instruction,
            int         => int,
            reset       => reset,
            dataAddress => upAddress,
            dataOut     => upDataOut,
            intAck      => intAck,
            progCounter => programCounter,
            readStrobe  => upReadStrobe,
            writeStrobe => upWriteStrobe
        );
    I_beamer : ahbBeamer
        GENERIC MAP (
            patternAddressBitNb => patternAddressBitNb,
            testOutBitNb        => testOutBitNb
        )
        PORT MAP (
            outX      => outX,
            hAddr     => hAddr,
            outY      => outY,
            hWData    => hWData,
            selSinCos => selSinCos,
            testOut   => testOut,
            hRData    => hRDataBeamer,
            hTrans    => hTrans,
            hWrite    => hWrite,
            hSel      => hSelBeamer,
            hReady    => hReadyBeamer,
            hResp     => hRespBeamer,
            hClk      => hClk,
            hReset_n  => hReset_n
        );
    I_rom : programRom
        GENERIC MAP (
            addressBitNb => programCounterBitNb,
            dataBitNb    => instructionBitNb
        )
        PORT MAP (
            address => programCounter,
            clock   => clock,
            en      => upEn,
            reset   => reset,
            dataOut => instruction
        );

END struct;
