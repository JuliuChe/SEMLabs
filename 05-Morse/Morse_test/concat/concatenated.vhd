-- VHDL Entity Morse_test.charToMorseController_tb.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:12:49 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2023.4 Built on 6 Oct 2023 at 01:57:26
--


ENTITY charToMorseController_tb IS
-- Declarations

END charToMorseController_tb ;





-- VHDL Entity Morse.unitCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2023.4 Built on 6 Oct 2023 at 01:57:26
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY unitCounter IS
    GENERIC( 
        unitCountDivide : positive := 10E3;
        unitCountBitNb  : positive := 3
    );
    PORT( 
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        startCounter : IN     std_ulogic;
        unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        done         : OUT    std_ulogic
    );

-- Declarations

END unitCounter ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library Common;
  use Common.CommonLib.all;

ARCHITECTURE studentVersion OF unitCounter IS

  signal unitCounter: unsigned(requiredBitNb(unitCountDivide)-1 downto 0);
  signal unitCountDone: std_ulogic;
  signal unitNbCounter: unsigned(unitnB'range);
  signal unitNbCountDone: std_ulogic;

BEGIN
                                                       -- count unit base period
  countUnitDuration: process(reset, clock)
  begin
    if reset = '1' then
      unitCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitCounter = 0 then
        if (startCounter = '1') or (unitNbCounter > 0) then
          unitCounter <= unitCounter + 1;
        end if;
      else
        if unitCountDone = '0' then
          unitCounter <= unitCounter + 1;
        else
          unitCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countUnitDuration;

  unitCountDone <= '1' when unitCounter = unitCountDivide
    else '0';
                                                     -- count unit period number
  countPeriods: process(reset, clock)
  begin
    if reset = '1' then
      unitNbCounter <= (others => '0');
    elsif rising_edge(clock) then
      if unitNbCounter = 0 then
        if startCounter = '1' then
          unitNbCounter <= unitNbCounter + 1;
        end if;
      else
        if unitNbCountDone = '0' then
          if unitCountDone = '1' then
            unitNbCounter <= unitNbCounter + 1;
          end if;
        else
          unitNbCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countPeriods;

  unitNbCountDone <= '1' when (unitNbCounter = unitNb) and (unitCountDone = '1')
    else '0';

  done <= unitNbCountDone;

END ARCHITECTURE studentVersion;




-- VHDL Entity Morse.charToMorseController.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 09:13:01 03/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2023.4 Built on 6 Oct 2023 at 01:57:26
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY charToMorseController IS
    GENERIC( 
        characterBitNb : positive := 8;
        unitCountBitNb : positive := 3
    );
    PORT( 
        morseOut     : OUT    std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        charNotReady : IN     std_ulogic;
        char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        startCounter : OUT    std_ulogic;
        unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        counterDone  : IN     std_ulogic;
        readChar     : OUT    std_ulogic
    );

-- Declarations

END charToMorseController ;





ARCHITECTURE studentVersion OF charToMorseController IS

  signal isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP,
         isQ, isR, isS, isT, isU, isV, isW, isX,
         isY, isZ,
         is0, is1, is2, is3, is4, is5, is6, is7,
         is8, is9 : std_ulogic;

type stateDote is (waitStartDot, sendDotStart, sendDotWait, sendDotSpacerStart, 
	sendDotSpacerWait, EndDot); 
type stateDash is (waitStartDash, sendDashStart, sendDashWait, sendDashSpacerStart, 
	sendDashSpacerWait, EndDash);
type stateChar is (waitForChar, storeChar, waitWordChar, waitWordCharSpacer, getNextChar,
	sendDot1, sendDash1, 
	sendDotWaitDot2, sendDotDot2, sendDotDash2, sendDashDot2, sendDashWaitDash2, sendDashDash2, 
	sendDotDotWaitDot3, sendDotDotDot3, sendDotDotDash3, sendDotDashDot3, sendDotDashWaitDash3, sendDotDashDash3, 
	sendDashDotWaitDot3, sendDashDotDot3, sendDashDotDash3, sendDashDashDot3, sendDashDashWaitDash3, sendDashDashDash3, 
	
	sendDotDotDotWaitDot4, sendDotDotDotDot4, sendDotDotDotDash4, 
	sendDotDotDashDot4, sendDotDotDashWaitDash4, sendDotDotDashDash4,
	sendDotDashDotWaitDot4, sendDotDashDotDot4,  
	
	sendDotDashDashDot4, sendDotDashDashWaitDash4, sendDotDashDashDash4,
	sendDashDotDotWaitDot4, sendDashDotDotDot4, sendDashDotDotDash4,
	sendDashDotDashDot4, sendDashDotDashWaitDash4, sendDashDotDashDash4,
	sendDashDashDotWaitDot4, sendDashDashDotDot4, sendDashDashDotDash4,
	sendDashDashDashDot4, sendDashDashDashWaitDash4, sendDashDashDashDash4,
	
	sendDotDotDotDotWaitDot5, sendDotDotDotDotDot5, 
	sendDotDotDotDotDash5,
	sendDotDotDotDashWaitDash5, sendDotDotDotDashDash5,
	sendDotDotDashDashWaitDash5, sendDotDotDashDashDash5,
	sendDashDotDotDotWaitDot5, sendDashDotDotDotDot5,
	sendDashDashDotDotWaitDot5, sendDashDashDotDotDot5,
	sendDashDashDashDotWaitDot5, sendDashDashDashDotDot5,
	sendDotDashDashDashWaitDash5, sendDotDashDashDashDash5,
	sendDashDashDashDashDot5,
	sendDashDashDashDashWaitDash5, sendDashDashDashDashDash5,
	
	
	endOfChar, sendSpacerWaitChar);

constant dotTime : positive := 1;
signal morseOutDot, strtCnterDot, dotSMActive, morseOutDash, strtCnterDash, dashSMActive, morseOutChar, strtCnterChar, charSMActive, sendDt, sendDs, rdChr : std_ulogic := '0';
signal unitNbDot, unitNbChar, unitNbDash : unsigned(unitNb'range) := to_unsigned(0, unitNb'length);
signal presentDot, nextDot:stateDote;
signal presentDash, nextDash:stateDash;
signal presentChar, nextChar : stateChar;

--Additionnal Inputs
signal sendDot, sendDash : std_ulogic;

--Additionnal outputs
signal dotSent, dashSent : std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
  --------------------------- CHAR SENT STATE MACHINE --------------------------
  nxt_Charstate : process(presentChar,isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP, isQ, isR, isS, isT, isU, isV, 
		 isW, isX, isY, isZ, is0, is1, is2, is3, is4, is5, is6, is7, is8, is9, 
		 charNotReady, counterDone, dashSent, dotSent)
	BEGIN
		case presentChar is
		
			-- Beginning of coding of a letter
			when waitForChar =>
				if charNotReady = '0' then 
					nextChar <= storeChar;
				else
					nextChar <= waitForChar;
				end if;
			when storeChar =>
				if (isA or isE or isF or isH or isI or isJ or isL or isP or isR 
				or isS or isU or isV or isW or is1 or is2 or is3 or is4 or is5) = '1' then 
					nextChar <= sendDot1;
				elsif (isB or isC or isD or isG or isK or isM or isN or isO or isQ
				or isT or isX or isY or isZ or is0 or is6 or is7 or is8 or is9) = '1' then
					nextChar <= sendDash1;
				else
					nextChar <= waitWordChar;
				end if;

			--Beginning of 1st Character : -
			when sendDot1 =>
				if dotSent = '1' then
					if (isF or isH or isI or isS or isU or isV or is2 or is3 or 
					is4 or is5) = '1' then
						nextChar <= sendDotWaitDot2;
					elsif (isA or isJ or isL or isP or isR or isW or is1) = '1' then
						nextChar <= sendDotDash2;
					else --char is e
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDot1;
				end if;
			when sendDash1 =>
				if dashSent = '1' then
					if (isB or isC or isD or isK or isN or isX or isY 
					or is6) = '1' then
						nextChar <= sendDashDot2;
					elsif (isG or isM or isO or isQ or isZ or is7 or is8 
					or is9 or is0) = '1' then
						nextChar <= sendDashWaitDash2;
					else --char is t
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDash1;
				end if;
				
			-- Beginning of 2nd Character : -/-
			when sendDotWaitDot2 =>
				nextChar <= sendDotDot2;
			when sendDotDot2 =>
				if dotSent = '1' then
					if (isH or isS or isV or is3 or is4 or is5) = '1' then
						nextChar <= sendDotDotWaitDot3;
					elsif (isF or isU or is2) = '1' then
						nextChar <= sendDotDotDash3;
					else --char is i
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDot2;
				end if;
			when sendDotDash2 =>
				if dashSent = '1' then
					if  (isL or  isR) = '1' then
						nextChar <= sendDotDashDot3;
					elsif (isJ or isP or isW or is1) = '1' then
						nextChar <= sendDotDashWaitDash3;
					else -- char is a
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDash2;
				end if;
			when sendDashDot2 =>
				if dotSent = '1' then
					if (isB or isD or isX or is6) = '1' then
						nextChar <= sendDashDotWaitDot3;
					elsif (isC or isK or isY) = '1' then
						nextChar <= sendDashDotDash3;
					else -- char is n 
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDot2;
				end if;
			when sendDashWaitDash2 =>
				nextChar <= sendDashDash2;
			when sendDashDash2 =>
				if dashSent = '1' then
					if (isG or isQ or isZ or is7) = '1' then
						nextChar <= sendDashDashDot3;
					elsif (isO or is8 or is9 or is0) = '1' then
						nextChar <= sendDashDashWaitDash3;
					else -- char is m
						nextChar <= endOfChar;
					end if;
				else
					nextChar <=  sendDashDash2;
				end if;
			-- End of 2nd Character : -/-	
			
			-- Beginning of 3rd Character: -/-/-
			when sendDotDotWaitDot3 =>
				nextChar <= sendDotDotDot3;
			when sendDotDotDot3 =>
				if dotSent = '1' then
					if (isH or is4 or is5) = '1' then
						nextChar <= sendDotDotDotWaitDot4;
					elsif (isV or is3) = '1' then
						nextChar <= sendDotDotDotDash4;
					else -- char is s
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDotDot3;
				end if;
			when sendDotDotDash3 =>
				if dashSent = '1' then
					if isF = '1' then
						nextChar <= sendDotDotDashDot4;
					elsif is2 = '1' then
						nextChar <= sendDotDotDashWaitDash4;
					else -- char is u
						nextChar <= endOfChar; 
					end if;
				else 
					nextChar <= sendDotDotDash3;
				end if;
			when sendDotDashDot3 =>
				if dotSent = '1' then
					if isL = '1'then
						nextChar <= sendDotDashDotWaitDot4;
					else -- char is r
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDashDot3;
				end if;
			when sendDotDashWaitDash3 =>
				nextChar <= sendDotDashDash3;
			when sendDotDashDash3 =>
				if dashSent = '1' then
					if isP = '1' then
						nextChar <= sendDotDashDashDot4;
					elsif (isJ or is1) = '1' then
						nextChar <= sendDotDashDashWaitDash4;
					else -- char is w
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDotDashDash3;
				end if;
			when sendDashDotWaitDot3 =>
				nextChar <= sendDashDotDot3;
			when sendDashDotDot3 =>
				if dotSent = '1' then
					if (isB or is6) = '1'  then
						nextChar <= sendDashDotDotWaitDot4;
					elsif isX = '1' then
						nextChar <= sendDashDotDotDash4;
					else -- char is d
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDotDot3;
				end if;
			when sendDashDotDash3 =>
				if dashSent = '1' then
					if isC = '1' then
						nextChar <= sendDashDotDashDot4;
					elsif isY = '1' then
						nextChar <= sendDashDotDashWaitDash4;
					else -- char is k
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDotDash3;
				end if;
			when sendDashDashDot3 =>
				if dotSent = '1' then
					if (isZ or is7) = '1' then
						nextChar <= sendDashDashDotWaitDot4; --z or 7 
					elsif isQ = '1' then
						nextChar <= sendDashDashDotDash4; -- q then end 
					else -- char is g
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDashDot3;
				end if;
			when sendDashDashWaitDash3 =>
				nextChar <= sendDashDashDash3;
			when sendDashDashDash3 =>
				if dashSent = '1' then
					if is8 = '1' then
						nextChar <= sendDashDashDashDot4;
					elsif (is0 or is9) = '1' then
						nextChar <= sendDashDashDashWaitDash4;
					else -- char is o
						nextChar <= endOfChar;
					end if;
				else
					nextChar <= sendDashDashDash3;
				end if;
			-- END of 3rd Character : -/-/-
			
			-- Beginning of 4th Character : -/-/-/-
				-- Beginning of 4th Character : -/-/-/Dot
			when sendDotDotDotWaitDot4 =>  nextChar <=  sendDotDotDotDot4;
			when sendDotDotDotDot4 =>
				if dotSent = '1' then
					if is5 = '1' then
						nextChar <= sendDotDotDotDotWaitDot5;
					elsif is4 = '1' then
						nextChar <= sendDotDotDotDotDash5;
					else 
						nextChar <= endOfChar; -- char is h 
					end if;
				else
					nextChar <= sendDotDotDotDot4;
				end if;
			when sendDotDotDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is f
				else
					nextChar <= sendDotDotDashDot4;
				end if;
			when sendDotDashDotWaitDot4 => nextChar <= sendDotDashDotDot4; 
			when sendDotDashDotDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is l
				else
					nextChar <= sendDotDashDotDot4;
				end if;
			when sendDotDashDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; --char is p
				else
					nextChar <= sendDotDashDashDot4;
				end if;
			when sendDashDotDotWaitDot4 =>  nextChar <=  sendDashDotDotDot4;
			when sendDashDotDotDot4 =>
				if dotSent = '1' then
					if is6 = '1' then
						nextChar <= sendDashDotDotDotWaitDot5; 
					else
						nextChar <= endOfChar; --char is b 
					end if;
				else
					nextChar <= sendDashDotDotDot4;
				end if;
			when sendDashDotDashDot4 =>
				if dotSent = '1' then
					nextChar <= endOfChar; -- char is c 
				else
					nextChar <= sendDashDotDashDot4;
				end if;
			when sendDashDashDashDot4 => 
				if dotSent = '1' then
					nextChar <= sendDashDashDashDotWaitDot5;
				else
					nextChar <= sendDashDashDashDot4;
				end if;
			when sendDashDashDotWaitDot4 =>  
				nextChar <=  sendDashDashDotDot4;
			when sendDashDashDotDot4 => 
				if dotSent = '1' then
					if is7 = '1' then
						nextChar <= sendDashDashDotDotWaitDot5;
					else
						nextChar <= endOfChar; -- char is z
					end if;
				else
					nextChar <= sendDashDashDotDot4;
				end if;
				
				-- Beginning of 4th Character : -/-/-/Dash
			when sendDotDotDotDash4 => 
				if dashSent = '1' then
					if is3 = '1' then
						nextChar <= sendDotDotDotDashWaitDash5;
					else 
						nextChar <= endOfChar; -- char is v
					end if;
				else
					nextChar <= sendDotDotDotDash4;
				end if;
			when sendDotDotDashWaitDash4 =>  
				nextChar <=  sendDotDotDashDash4;
			when sendDotDotDashDash4 =>
				if dashSent = '1' then
					nextChar <= sendDotDotDashDashWaitDash5;
				else
					nextChar <= sendDotDotDashDash4;
				end if;
			when sendDotDashDashWaitDash4 =>  nextChar <=  sendDotDashDashDash4;
			when sendDotDashDashDash4 =>
				if dashSent = '1' then
					if is1 = '1' then
						nextChar <= sendDotDashDashDashWaitDash5; 
					else
						nextChar <= endOfChar; -- char is j
					end if;
				else
					nextChar <= sendDotDashDashDash4;
				end if;
			when sendDashDotDotDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is x
				else
					nextChar <= sendDashDotDotDash4;
				end if;
			when sendDashDotDashWaitDash4 =>  
				nextChar <=  sendDashDotDashDash4;
			when sendDashDotDashDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is y
				else
					nextChar <= sendDashDotDashDash4;
				end if;
			when sendDashDashDotDash4 =>
				if dashSent = '1' then
					nextChar <= endOfChar; -- char is q
				else
					nextChar <= sendDashDashDotDash4;
				end if;
			when sendDashDashDashWaitDash4 =>  
				nextChar <=  sendDashDashDashDash4;
			when sendDashDashDashDash4 => 
				if dashSent = '1' then
					if is9 = '1' then
						nextChar <= sendDashDashDashDashDot5;
					elsif is0 = '1' then
						nextChar <= sendDashDashDashDashWaitDash5;
					end if;
				else
					nextChar <= sendDashDashDashDash4;
				end if;
				-- End of 4th Character : -/-/-/Dash
			-- End of 4th Character : -/-/-/-
			
			-- Beginning of 5th Character : -/-/-/-/-
			when sendDotDotDotDotWaitDot5 => nextChar <= sendDotDotDotDotDot5; 
			when sendDotDotDotDotDot5 =>  
				if dotSent = '1' then 
					nextChar <=  endOfChar; --char is 5
				else
					nextChar <= sendDotDotDotDotDot5 ;
				end if;
			when sendDotDotDotDotDash5 => 
			if dashSent = '1' then 
				nextChar <= endOfChar; --char is 4
			else
				nextChar <= sendDotDotDotDotDash5 ;
			end if;
			when sendDashDotDotDotWaitDot5 => 
				nextChar <= sendDashDotDotDotDot5;
			when sendDashDotDotDotDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar;  -- char is 6
				else
					nextChar <= sendDashDotDotDotDot5;
			end if;
			when sendDashDashDotDotWaitDot5 => nextChar <= sendDashDashDotDotDot5;
			when sendDashDashDotDotDot5 => 
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 7
				else
					nextChar <= sendDashDashDotDotDot5;
			end if;
			when sendDotDotDotDashWaitDash5 => nextChar <= sendDotDotDotDashDash5;
			when sendDotDotDotDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar;--char is 3
				else
					nextChar <= sendDotDotDotDashDash5;
				end if;
			when sendDotDotDashDashWaitDash5 => 
				nextChar <= sendDotDotDashDashDash5;
			when sendDotDotDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 2
				else
					nextChar <= sendDotDotDashDashDash5;
			end if;
			when sendDotDashDashDashWaitDash5 => 
				nextChar <= sendDotDashDashDashDash5;
			when sendDotDashDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 1
				else
					nextChar <= sendDotDashDashDashDash5;
				end if;
			when sendDashDashDashDotWaitDot5 => 
				nextChar <= sendDashDashDashDotDot5;
			when sendDashDashDashDotDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 8
				else
					nextChar <= sendDashDashDashDotDot5;
				end if;
			when sendDashDashDashDashDot5 =>  
				if dotSent = '1' then 
					nextChar <= endOfChar; -- char is 9
				else
					nextChar <= sendDashDashDashDashDot5;
				end if;
			when sendDashDashDashDashWaitDash5 => 
				nextChar <= sendDashDashDashDashDash5;
			when sendDashDashDashDashDash5 => 
				if dashSent = '1' then 
					nextChar <= endOfChar; -- char is 0  
				else
					nextChar <= sendDashDashDashDashDash5;
			end if;
			-- End of 5th Character : -/-/-/-/-
			
			
			
			-- End of coding of a letter
			when waitWordChar =>
				nextChar <= waitWordCharSpacer;
			when waitWordCharSpacer =>
				if counterDone = '1' then
					nextChar <= endOfChar;
				else
					nextChar <= waitWordCharSpacer;
				end if;
			when endOfChar =>
				nextChar <= sendSpacerWaitChar;
			when sendSpacerWaitChar =>
				if counterDone = '1' then 
					nextChar <= getNextChar;
				else
					nextChar <= sendSpacerWaitChar;
				end if;
			when getNextChar =>
				nextChar <= waitForChar;
			when others =>
				nextChar <= waitForChar; 
		end case;
	end process;
	
	-- CHAR SENT STATE MACHINE
	state_Char_reg : process(clock,reset)
	BEGIN
		if reset = '1' then
			presentChar <= waitForChar;
		elsif rising_edge(clock) then
			presentChar <= nextChar;
		end if;
	end process;
	
	
	-- OUTPUT : 
	outputChar : process(presentChar, counterDone)
	BEGIN
		case presentChar is
			when waitForChar =>
				charSMActive <= '0';
				sendDs <= '0';
				sendDt <= '0';
				morseOutChar <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				strtCnterChar <= '0';
				rdChr <= '0';
			when storeChar =>
				sendDs <= '0';
				sendDt <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDot1 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDash1 =>
				sendDs <= '1';
				sendDt <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDotDot2 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDotDash2 =>
				sendDs <= '1';
				sendDt <= '0';
			when sendDashDot2 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDashDash2 =>
				sendDs <= '1';
				sendDt <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDotDotDot3 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDotDotDash3 =>
				sendDs <= '1';
				sendDt <= '0';
			when sendDotDashDot3 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDotDashDash3 =>
				sendDs <= '1';
				sendDt <= '0';
			-- CHAR SENT STATE MACHINE
			when sendDashDotDot3 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDashDotDash3 =>
				sendDs <= '1';
				sendDt <= '0';
			when sendDashDashDot3 =>
				sendDs <= '0';
				sendDt <= '1';
			when sendDashDashDash3 =>
				sendDs <= '1';
				sendDt <= '0';
			when sendDotDotDotDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDotDotDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDotDotDashDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDotDashDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDotDashDotDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDashDashDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDashDashDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDotDotDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDotDotDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDotDashDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDotDashDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDashDotDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDashDotDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDashDashDot4 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDashDashDash4 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDotDotDotDotDot5 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDotDotDotDash5 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDotDotDotDashDash5 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDotDotDashDashDash5 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDotDotDotDot5 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDashDotDotDot5 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDashDashDotDot5 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDotDashDashDashDash5 => 
				sendDs <= '1'; 
				sendDt <= '0';
			when sendDashDashDashDashDot5 => 
				sendDs <= '0'; 
				sendDt <= '1';
			when sendDashDashDashDashDash5 => 
				sendDs <= '1'; 
				sendDt <= '0';
			-- CHAR SENT STATE MACHINE
			when waitWordChar =>
				morseOutChar <= '0';
				charSMActive <= '1';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '1';
				rdChr <= '0';
			when waitWordCharSpacer =>
				unitNbChar <= to_unsigned(2*dotTime, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when endOfChar =>
				morseOutChar <= '0';
				charSMActive <= '1';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '1';
				rdChr <= '0';
			when sendSpacerWaitChar =>
				unitNbChar <= to_unsigned(2*dotTime, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			when getNextChar =>
				morseOutChar <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '1';
			when others =>
				morseOutChar <= '0';
				unitNbChar <= to_unsigned(0, unitNb'length);
				charSMActive <= '0';
				sendDs <= '0';
				sendDt <= '0';
				strtCnterChar <= '0';
				rdChr <= '0';
			end case;
	end process;
  
  --------------------------- END CHAR SENT STATE MACHINE ----------------------
  
  
  --------------------------- DOT SENT STATE MACHINE ---------------------------
	nxt_Dotstate : process(presentDot,sendDot, counterDone)
	BEGIN
		case presentDot is
			when waitStartDot =>
				if sendDot = '1' then 
					nextDot <= sendDotStart;
				else
					nextDot <= waitStartDot;
				end if;
			when sendDotStart =>
				nextDot <= sendDotWait;
			when sendDotWait =>
				if counterDone = '1' then
					nextDot <= sendDotSpacerStart;
				else
					nextDot <= sendDotWait;
				end if;
			when sendDotSpacerStart =>
				nextDot <= sendDotSpacerWait;
			when sendDotSpacerWait =>
				if counterDone = '1' then
					nextDot <= EndDot;
				else
					nextDot <= sendDotSpacerWait;
				end if;
			when endDot =>
				nextDot <= waitStartDot;
			when others =>
				nextDot <= waitStartDot; 
		end case;
	end process;
	
	state_Dot_reg : process(clock,reset)
	BEGIN
		if reset = '1' then
			presentDot <= waitStartDot;
			
		elsif rising_edge(clock) then
			presentDot <= nextDot;
		end if;
	end process;
	
	
	-- OUTPUT : morseOut, unitNb, dotSent,startCounter
	outputDot : process(presentDot)
	BEGIN
		case presentDot is
			when waitStartDot =>
				morseOutDot <= '0';
				dotSMActive <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when sendDotStart =>
				morseOutDot <= '0';
				dotSMActive <= '1';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '1';
			when sendDotWait =>
				morseOutDot <= '1';
				unitNbDot <= to_unsigned(dotTime, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when sendDotSpacerStart =>
				morseOutDot <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '1';
			when sendDotSpacerWait =>
				morseOutDot <= '0';
				unitNbDot <= to_unsigned(dotTime, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
			when endDot =>
				morseOutDot <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '1';
				strtCnterDot <= '0';
				--sendDt <= '0';
			when others =>
				morseOutDot <= '0';
				dotSMActive <= '0';
				unitNbDot <= to_unsigned(0, unitNb'length);
				dotSent <= '0';
				strtCnterDot <= '0';
		end case;
	end process;
		
------------------------- END DOT SENT STATE MACHINE --------------------------		

--------------------------- DASH SENT STATE MACHINE ---------------------------
	nxt_Dashstate : process(presentDash,sendDash, counterDone)
	BEGIN
		case presentDash is
			when waitStartDash =>
				if sendDash = '1' then 
					nextDash <= sendDashStart;
				else
					nextDash <= waitStartDash;
				end if;
			when sendDashStart =>
				nextDash <= sendDashWait;
			when sendDashWait =>
				if counterDone = '1' then
					nextDash <= sendDashSpacerStart;
				else
					nextDash <= sendDashWait;
				end if;
			when sendDashSpacerStart =>
				nextDash <= sendDashSpacerWait;
			when sendDashSpacerWait =>
				if counterDone = '1' then
					nextDash <= EndDash;
				else
					nextDash <= sendDashSpacerWait;
				end if;
			when endDash =>
				nextDash <= waitStartDash;
			when others =>
				nextDash <= waitStartDash; 
		end case;
	end process;
	
	state_Dashreg : process(clock,reset)
		BEGIN
		if reset = '1' then
			presentDash <= waitStartDash;
		elsif rising_edge(clock) then
			presentDash <= nextDash;
		end if;
	end process;
	
	
	-- OUTPUT : morseOut, unitNb, dashSent,startCounter
	outputDash : process(presentDash)
	BEGIN
		case presentDash is
			when waitStartDash =>
				morseOutDash <= '0';
				dashSMActive <= '0';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when sendDashStart =>
				morseOutDash <= '0';
				dashSMActive <= '1';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '1';
			when sendDashWait =>
				morseOutDash <= '1';
				unitNbDash <= to_unsigned(3*dotTime, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when sendDashSpacerStart =>
				morseOutDash <= '0';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '1';
			when sendDashSpacerWait =>
				morseOutDash <= '0';
				unitNbDash <= to_unsigned(dotTime, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
			when endDash =>
				morseOutDash <= '0';
				unitNbDash <= to_unsigned(0, unitNb'length);
				dashSent <= '1';
				strtCnterDash <= '0';
				--sendDash <= '0';
			when others =>
				dashSMActive <= '0';
				morseOutDash <= '0';
				unitNbDash <=to_unsigned(0, unitNb'length);
				dashSent <= '0';
				strtCnterDash <= '0';
		end case;
	end process;
------------------------- END DASH SENT STATE MACHINE --------------------------			
			


  ------------------------------------------------------------------------------
                                                   -- conditions for morse units
  isA <= '1' when std_match(unsigned(char), "1-0" & x"1") else '0';
  isB <= '1' when std_match(unsigned(char), "1-0" & x"2") else '0';
  isC <= '1' when std_match(unsigned(char), "1-0" & x"3") else '0';
  isD <= '1' when std_match(unsigned(char), "1-0" & x"4") else '0';
  isE <= '1' when std_match(unsigned(char), "1-0" & x"5") else '0';
  isF <= '1' when std_match(unsigned(char), "1-0" & x"6") else '0';
  isG <= '1' when std_match(unsigned(char), "1-0" & x"7") else '0';
  isH <= '1' when std_match(unsigned(char), "1-0" & x"8") else '0';
  isI <= '1' when std_match(unsigned(char), "1-0" & x"9") else '0';
  isJ <= '1' when std_match(unsigned(char), "1-0" & x"A") else '0';
  isK <= '1' when std_match(unsigned(char), "1-0" & x"B") else '0';
  isL <= '1' when std_match(unsigned(char), "1-0" & x"C") else '0';
  isM <= '1' when std_match(unsigned(char), "1-0" & x"D") else '0';
  isN <= '1' when std_match(unsigned(char), "1-0" & x"E") else '0';
  isO <= '1' when std_match(unsigned(char), "1-0" & x"F") else '0';
  isP <= '1' when std_match(unsigned(char), "1-1" & x"0") else '0';
  isQ <= '1' when std_match(unsigned(char), "1-1" & x"1") else '0';
  isR <= '1' when std_match(unsigned(char), "1-1" & x"2") else '0';
  isS <= '1' when std_match(unsigned(char), "1-1" & x"3") else '0';
  isT <= '1' when std_match(unsigned(char), "1-1" & x"4") else '0';
  isU <= '1' when std_match(unsigned(char), "1-1" & x"5") else '0';
  isV <= '1' when std_match(unsigned(char), "1-1" & x"6") else '0';
  isW <= '1' when std_match(unsigned(char), "1-1" & x"7") else '0';
  isX <= '1' when std_match(unsigned(char), "1-1" & x"8") else '0';
  isY <= '1' when std_match(unsigned(char), "1-1" & x"9") else '0';
  isZ <= '1' when std_match(unsigned(char), "1-1" & x"A") else '0';
  is0 <= '1' when std_match(unsigned(char), "011" & x"0") else '0';
  is1 <= '1' when std_match(unsigned(char), "011" & x"1") else '0';
  is2 <= '1' when std_match(unsigned(char), "011" & x"2") else '0';
  is3 <= '1' when std_match(unsigned(char), "011" & x"3") else '0';
  is4 <= '1' when std_match(unsigned(char), "011" & x"4") else '0';
  is5 <= '1' when std_match(unsigned(char), "011" & x"5") else '0';
  is6 <= '1' when std_match(unsigned(char), "011" & x"6") else '0';
  is7 <= '1' when std_match(unsigned(char), "011" & x"7") else '0';
  is8 <= '1' when std_match(unsigned(char), "011" & x"8") else '0';
  is9 <= '1' when std_match(unsigned(char), "011" & x"9") else '0';
  
  sendDot <= sendDt;
  sendDash <= sendDs;
  
  morseOut <= morseOutDash when dashSMActive = '1' else morseOutDot when dotSMActive = '1' else morseOutChar when charSMActive = '1' else '0';
  startCounter <= strtCnterDot when dotSMActive = '1' else dashSMActive when dashSMActive = '1' else strtCnterChar when charSMActive = '1' else '0';
  readChar <= rdChr;
  unitNb <= unitNbDot when dotSMActive = '1' else unitNbDash when dashSMActive = '1' else unitNbChar when charSMActive = '1' else to_unsigned(0, unitNb'length);

END ARCHITECTURE studentVersion;




-- VHDL Entity Morse_test.charToMorseController_tester.interface
--
-- Created:
--          by - axel.amand.UNKNOWN (WE7860)
--          at - 14:50:43 28.04.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2023.4 Built on 6 Oct 2023 at 01:57:26
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

ENTITY charToMorseController_tester IS
    GENERIC( 
        clockFrequency : real;
        characterBitNb : positive
    );
    PORT( 
        morseOut     : IN     std_ulogic;
        readChar     : IN     std_ulogic;
        char         : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        charNotReady : OUT    std_ulogic;
        clock        : OUT    std_ulogic;
        reset        : OUT    std_ulogic
    );

-- Declarations

END charToMorseController_tester ;





LIBRARY std;
  USE std.textio.all;
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

PACKAGE testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string);


  --============================================================================
  -- string manipulation
  --

                                                      -- conversion to lowercase
  function lc(value : string) return string;
  procedure lc(value : inout line);
                                                      -- conversion to uppercase
  function uc(value : string) return string;
  procedure uc(value : inout line);
                                            -- expand a string to a given length
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string;
                     -- remove separator characters at beginning and end of line
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  );
  procedure rm_side_separators(
    value : inout line
  );
                           -- remove multiple occurences of separator characters
  procedure trim_line(
    value : inout line;
    separators : in string
  );

  procedure trim_line(
    value : inout line
   );
                                -- remove all occurences of separator characters
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  );

  procedure rm_all_separators(
    value : inout line
  );
                                                   -- find and remove first word
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  );

  procedure read_first(
    value : inout line;
    first : out line
   );
                                                    -- find and remove last word
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  );

  procedure read_last(
    value : inout line;
    last : out line
   );


  --============================================================================
  -- formatted string output
  --
  -- format codes:
  --  code  integer real std_logic std_(u)logic_vector (un)signed time
  --    b       v            v               v              v           binary
  --    c                                                               character
  --    d       v     v      v               v              v           decimal
  --    e                                                               real numbers, with power of 10 exponent
  --    f       v     v                                                 fixed point real numbers
  --    s                                                               string
  --    ts                                                          v   time in seconds
  --    tm                                                          v   time in milliseconds
  --    tu                                                          v   time in microseconds
  --    tn                                                          v   time in nanoseconds
  --    tp                                                          v   time in picoseconds
  --    x       v            v               v              v           hexadecimal
  --    X       v            v               v              v           hexadecimal with upper-case letters

  function sprintf(format : string; value : integer          ) return string;
  function sprintf(format : string; value : real             ) return string;
  function sprintf(format : string; value : std_logic        ) return string;
  function sprintf(format : string; value : std_ulogic_vector) return string;
  function sprintf(format : string; value : std_logic_vector ) return string;
  function sprintf(format : string; value : unsigned         ) return string;
  function sprintf(format : string; value : signed           ) return string;
  function sprintf(format : string; value : time             ) return string;

  --============================================================================
  -- formatted string input
  --
  subtype nibbleUlogicType is std_ulogic_vector(3 downto 0);
  subtype nibbleUnsignedType is unsigned(3 downto 0);

  function sscanf(value : character) return natural;
  function sscanf(value : character) return nibbleUlogicType;
  function sscanf(value : character) return nibbleUnsignedType;
  function sscanf(value : string   ) return natural;
  function sscanf(value : string   ) return unsigned;
  function sscanf(value : string   ) return std_ulogic_vector;
  function sscanf(value : string   ) return time;

  procedure sscanf(value : inout line; time_val : out time);

END testUtils;




PACKAGE BODY testUtils IS

  --============================================================================
  -- console output
  --

  procedure print(value : string) is
    variable my_line : line;
  begin
    write(my_line, value);
    writeLine(output, my_line);
    deallocate(my_line);
  end print;


  --============================================================================
  -- string manipulation
  --

  ------------------------------------------------------------------------------
  -- change to lowercase
  ------------------------------------------------------------------------------
  procedure lc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'A') and (value(index) <= 'Z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('A')
                                    + character'pos('a')
                                      );
      end if;
    end loop;
  end lc;

  function lc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    lc(out_line);
    return(out_line.all);
  end lc;

  ------------------------------------------------------------------------------
  -- change to uppercase
  ------------------------------------------------------------------------------
  procedure uc(value: inout line) is
    variable out_line: line;
  begin
    for index in value'range loop
      if (value(index) >= 'a') and (value(index) <= 'z') then
        value(index) := character'val(character'pos(value(index))
                                    - character'pos('a')
                                    + character'pos('A')
                                      );
      end if;
    end loop;
  end uc;

  function uc(value: string) return string is
    variable out_line: line;
  begin
    write(out_line, value);
    uc(out_line);
    return(out_line.all);
  end uc;

  ------------------------------------------------------------------------------
  -- formatted string output: padding and justifying
  ------------------------------------------------------------------------------
  function pad(
    value           : string;
    string_length   : natural;
    fill_char       : character := ' ';
    right_justify   : boolean := false
  ) return string is
    variable value_line : line;
    variable out_line : line;
    variable value_length : natural;
    variable shift_sign : boolean;
  begin
    write(value_line, value);
    value_length := value_line.all'length;
    if string_length = 0 then
      write(out_line, value_line.all);
    elsif string_length > value_length then
      if right_justify then
        if (value_line.all(value_line.all'left) <= '-') and not(fill_char = ' ') then
          shift_sign := true;
          write(out_line, value_line.all(value_line.all'left));
        end if;
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
      if shift_sign then
        write(out_line, value_line.all(value_line.all'left+1 to value_line.all'right));
      else
        write(out_line, value_line.all);
      end if;
      if not right_justify then
        for index in 1 to string_length-value_length loop
          write(out_line, fill_char);
        end loop;
      end if;
    elsif string_length < value_length then
      write(out_line, '#');
      write(out_line, value_line.all(value_length-string_length+2 to value_length));
    else
      write(out_line, value_line.all);
    end if;
    deallocate(value_line);
    return(out_line.all);
  end pad;

  ------------------------------------------------------------------------------
  -- remove separator characters at beginning and end of line
  ------------------------------------------------------------------------------
  procedure rm_side_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line : line    := value;
    variable found      : boolean := false;
    variable position   : integer := 0;
  begin
    -- remove all separators in the beginning
    position := -1;
    for character_index in input_line'range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(position+1 to input_line'right) );
   end if;

   -- remove all separators in the end
    position := -1;
    for character_index in input_line'reverse_range loop
      found := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          found := true;
        end if;
      end loop;
      if found then
          position := character_index;
      else
          exit;
      end if;
   end loop;
   if position > -1 then
     input_line := new string'( input_line(input_line'left to position-1) );
   end if;

   value := input_line;
  end;

  procedure rm_side_separators(value : inout line) is
  begin
    rm_side_separators(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove multiple occurences of separator characters, keeping one single
  ------------------------------------------------------------------------------
  procedure trim_line(
    value : inout line;
    separators : in string
  ) is
    variable input_line: line := value;
    variable output_line: line := new string'("");
    variable is_separator, was_separator : boolean := false;
  begin
    rm_side_separators(input_line);
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not (is_separator and was_separator) then
        write(output_line, input_line.all(character_index));
      end if;
      was_separator := is_separator;
    end loop;

    value := output_line;
  end;

  procedure trim_line(value : inout line) is
  begin
    trim_line(value, " :" & ht);
  end;

  ------------------------------------------------------------------------------
  -- remove all occurences of separator characters
  ------------------------------------------------------------------------------
  procedure rm_all_separators(
    value : inout line;
    separators : in string
  ) is
    variable input_line   : line    := value;
    variable is_separator : boolean := false;
  begin

    -- remove separators from beginn and end of the line
    -- rm_separator_be(value, separators);

    -- empty output line
    value := new string'("");

    -- find all separator symbols
    for character_index in input_line'range loop
      is_separator := false;
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          is_separator := true;
        end if;
      end loop;
      if not is_separator then
        write(value, input_line.all(character_index));
      end if;
    end loop;

  end;

  procedure rm_all_separators(value : inout line) is
  begin
    rm_all_separators(value, " _." & ht);
  end;

  ------------------------------------------------------------------------------
  -- read first "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_first(
    value : inout line;
    separators : in string;
    first : out line
  ) is
    variable input_line: line;
    variable position: natural := 0;
  begin
    input_line := value;
    for character_index in input_line.all'reverse_range loop
      for separator_index in separators'range loop
        if input_line.all(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position > 1 then
      first := new string'(input_line.all(input_line'left to position-1));
	    value := new string'(input_line(position+1 to input_line'right));
    else
      first := new string'(input_line.all);
	    value := new string'("");
    end if;
  end;

  procedure read_first(value : inout line; first : out line) is
  begin
    read_first(value, " :" & ht, first);
  end;

  ------------------------------------------------------------------------------
  -- read last "word" out of a line
  ------------------------------------------------------------------------------
  procedure read_last(
    value : inout line;
    separators : in string;
    last : out line
  ) is
    variable input_line: line := value;
    variable position: natural := 0;
  begin
    for character_index in input_line'range loop
      for separator_index in separators'range loop
        if input_line(character_index) = separators(separator_index) then
          position := character_index;
        end if;
      end loop;
    end loop;
    if position <= input_line'right and
       position >  0                then
      value := new string'(input_line(input_line'left to position-1));
      last  := new string'(input_line(position+1 to input_line'right));
    else
      last := new string'(input_line.all);
    end if;
  end;

  procedure read_last(value : inout line; last : out line) is
  begin
    read_last(value, " :" & ht, last);
  end;


  --============================================================================
  -- formatted string output, internal functions
  --

  ------------------------------------------------------------------------------
  -- get format specification
  ------------------------------------------------------------------------------
  procedure get_format_items(
    format          : string;
    right_justify   : out boolean;
    add_sign        : out boolean;
    fill_char       : out character;
    total_length    : out natural;
    point_precision : out natural;
    format_type     : inout line
  ) is
    variable find_sign : boolean := false;
    variable find_padding : boolean := false;
    variable find_length : boolean := false;
    variable find_precision : boolean := false;
    variable find_type : boolean := false;
    variable right_justify_int : boolean := true;
    variable total_length_int : natural := 0;
    variable point_precision_int : natural := 0;
  begin
    add_sign := false;
    fill_char := ' ';
    for index in 1 to format'length loop
      if find_type then
        write(format_type, format(index));
      end if;
      if find_precision then
        if (format(index) >= '0') and (format(index) <= '9') then
          point_precision_int := 10*point_precision_int + character'pos(format(index)) - character'pos('0');
          if format(index+1) >= 'A' then
            find_precision := false;
            find_type := true;
          end if;
        end if;
      end if;
      if find_length then
        if (format(index) >= '0') and (format(index) <= '9') then
          total_length_int := 10*total_length_int + character'pos(format(index)) - character'pos('0');
        end if;
        if format(index) = '.' then
          find_length := false;
          find_precision := true;
        elsif format(index+1) >= 'A' then
          find_length := false;
          find_type := true;
        end if;
      end if;
      if find_padding then
        if format(index) = '0' then
          if right_justify_int then
            fill_char := '0';
          end if;
        end if;
        find_padding := false;
        if format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if find_sign then
        if format(index) = '-' then
          right_justify_int := false;
        end if;
        if format(index) = '+' then
          add_sign := true;
        end if;
        find_sign := false;
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
      if format(index) = '%' then
        if format(index+1) <= '-' then
          find_sign := true;
        elsif format(index+1) = '0' then
          find_padding := true;
        elsif format(index+1) >= 'A' then
          find_type := true;
        else
          find_length := true;
        end if;
      end if;
    end loop;
    right_justify := right_justify_int;
    total_length := total_length_int;
    point_precision := point_precision_int;
  end get_format_items;


  ------------------------------------------------------------------------------
  -- formatted string output: converting std_ulogic to character
  ------------------------------------------------------------------------------
  function to_character(value: std_ulogic) return character is
    variable out_value: character;
  begin
    case value is
      when 'U' => out_value := 'U';
      when 'X' => out_value := 'X';
      when '0' => out_value := '0';
      when '1' => out_value := '1';
      when 'Z' => out_value := 'Z';
      when 'W' => out_value := 'W';
      when 'L' => out_value := 'L';
      when 'H' => out_value := 'H';
      when '-' => out_value := '-';
    end case;
    return(out_value);
  end to_character;

  ------------------------------------------------------------------------------
  -- formatted string output: binary integer
  ------------------------------------------------------------------------------
  function sprintf_b(value: std_ulogic_vector) return string is
    variable out_line : line;
  begin
    for index in value'range loop
      write(out_line, to_character(value(index)));
    end loop;
    return(out_line.all);
  end sprintf_b;

  ------------------------------------------------------------------------------
  -- formatted string output: decimal integer
  ------------------------------------------------------------------------------
  function sprintf_d(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    value           : integer
  ) return string is
    variable value_line : line;
  begin
    if add_sign and (value >= 0) then
      write(value_line, '+');
    end if;
    write(value_line, value);
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_d;

  ------------------------------------------------------------------------------
  -- formatted string output: fixed point real
  ------------------------------------------------------------------------------
  function sprintf_f(
    right_justify   : boolean;
    add_sign        : boolean;
    fill_char       : character;
    string_length   : natural;
    point_precision : natural;
    value           : real
  ) return string is
    variable point_precision_int : natural;
    variable integer_part : integer;
    variable decimal_part : natural;
    variable value_line : line;
  begin
    if point_precision = 0 then
      point_precision_int := 6;
    else
      point_precision_int := point_precision;
    end if;
    if value >= 0.0 then
      integer_part := integer(value-0.5);
    else
      integer_part := - integer(-value-0.5);
    end if;
    decimal_part := abs(integer((value-real(integer_part))*(10.0**point_precision_int)));
    if add_sign and (value >= 0.0) then
      write(value_line, '+');
    end if;
    write(value_line, integer_part);
    write(value_line, '.');
    write(value_line, sprintf_d(true, false, '0', point_precision_int, decimal_part));
    if string_length = 0 then
      return(value_line.all);
    else
      return(pad(value_line.all, string_length, fill_char, right_justify));
    end if;
  end sprintf_f;

  ------------------------------------------------------------------------------
  -- formatted string output: hexadecimal integer
  ------------------------------------------------------------------------------
  function sprintf_X(
    extend_unsigned : boolean;
    value           : std_ulogic_vector
  ) return string is
    variable bit_count : positive;
    variable value_line : line;
    variable out_line : line;
    variable nibble: string(1 to 4);
  begin
    bit_count := value'length;
    while (bit_count mod 4) /= 0 loop
      if extend_unsigned then
        write(value_line, to_character('0'));
      else
        write(value_line, to_character(value(value'high)));
      end if;
      bit_count := bit_count + 1;
    end loop;
    write(value_line, sprintf_b(value));
    for index in value_line.all'range loop
      if (index mod 4) = 0 then
        nibble := value_line.all(index-3 to index);
        case nibble is
          when "0000" => write(out_line, 0);
          when "0001" => write(out_line, 1);
          when "0010" => write(out_line, 2);
          when "0011" => write(out_line, 3);
          when "0100" => write(out_line, 4);
          when "0101" => write(out_line, 5);
          when "0110" => write(out_line, 6);
          when "0111" => write(out_line, 7);
          when "1000" => write(out_line, 8);
          when "1001" => write(out_line, 9);
          when "1010" => write(out_line, 'A');
          when "1011" => write(out_line, 'B');
          when "1100" => write(out_line, 'C');
          when "1101" => write(out_line, 'D');
          when "1110" => write(out_line, 'E');
          when "1111" => write(out_line, 'F');
          when others => write(out_line, 'X');
        end case;
      end if;
    end loop;
    return(out_line.all);
  end sprintf_X;


  --============================================================================
  -- formatted string output, interface functions
  --

  ------------------------------------------------------------------------------
  -- integer
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : integer) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all = "b" then
      if string_length = 0 then
        string_length := 8;
      end if;
      return(sprintf_b(std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, string_length, value));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, real(value)));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if string_length = 0 then
        string_length := 8;
      end if;
      string_length := 4*string_length;
      if format_type.all = "X" then
        return(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0))));
      else
        return(lc(sprintf_X(false, std_ulogic_vector(to_signed(value, string_length+1)(string_length-1 downto 0)))));
      end if;
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- real
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : real) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "d") or (point_precision = 0) then
      return(sprintf_d(right_justify, add_sign, fill_char,
                       string_length, integer(value)));
    elsif format_type.all = "f" then
      return(sprintf_f(right_justify, add_sign, fill_char,
                       string_length, point_precision, value));
    else
      return("Unhandled format type: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable logic_vector: std_logic_vector(1 to 1);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      logic_vector(1) := value;
      return(sprintf(format, std_ulogic_vector(logic_vector)));
    else
      return("Not a std_logic format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_ulogic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_ulogic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if format_type.all = "b" then
      return(pad(sprintf_b(value), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(unsigned(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if format_type.all = "X" then
        return(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, value), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a std_ulogic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- std_logic_vector
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : std_logic_vector) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not a std_logic_vector format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- unsigned
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : unsigned) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if (format_type.all = "b") or (format_type.all = "d") or
       (format_type.all = "X") or (format_type.all = "x") then
      return(sprintf(format, std_ulogic_vector(value)));
    else
      return("Not an unsigned format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- signed
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : signed) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable bit_string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     bit_string_length, point_precision, format_type);
    if (fill_char = '0') and (value(value'left) = '1') then
      fill_char := '1';
    end if;
    if format_type.all = "b" then
      return(pad(sprintf_b(std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
    elsif format_type.all = "d" then
      return(sprintf_d(right_justify, add_sign, fill_char, bit_string_length, to_integer(signed(value))));
    elsif (format_type.all = "X") or (format_type.all = "x") then
      if fill_char = '1' then
        fill_char := 'F';
      end if;
      if format_type.all = "X" then
        return(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify));
      else
        return(lc(pad(sprintf_X(true, std_ulogic_vector(value)), bit_string_length, fill_char, right_justify)));
      end if;
    else
      return("Not a signed format: '" & format_type.all & "'");
    end if;
  end sprintf;

  ------------------------------------------------------------------------------
  -- time
  ------------------------------------------------------------------------------
  function sprintf(format : string; value : time) return string is
    variable right_justify : boolean;
    variable add_sign : boolean;
    variable fill_char : character;
    variable string_length : natural;
    variable point_precision : natural;
    variable format_type : line;
    variable scaling : real;
    variable base_time : time;
    variable unit : string(1 to 3);
  begin
    get_format_items(format, right_justify, add_sign, fill_char,
                     string_length, point_precision, format_type);
    if format_type.all(format_type.all'left) = 't' then
      scaling := 10.0**point_precision;
      if format_type.all = "tp" then
        base_time := 1 ps;
        unit := " ps";
      elsif format_type.all = "tn" then
        base_time := 1 ns;
        unit := " ns";
      elsif format_type.all = "tu" then
        base_time := 1 us;
        unit := " us";
      elsif format_type.all = "tm" then
        base_time := 1 ms;
        unit := " ms";
      elsif format_type.all = "ts" then
        base_time := 1 sec;
        unit := " s.";
      else
        return("Undefined time format: '" & format_type.all & "'");
      end if;
      if point_precision = 0 then
        return(sprintf_d(right_justify, add_sign, fill_char,
                         string_length, value/base_time) & unit);
      else
        return(sprintf_f(right_justify, add_sign, fill_char, string_length,
                         point_precision, real(scaling*value/base_time)/scaling) & unit);
      end if;
    else
      return("Not a time format: '" & format_type.all & "'");
    end if;
  end sprintf;


  --============================================================================
  -- formatted string input
  ------------------------------------------------------------------------------

  ------------------------------------------------------------------------------
  -- read a nibble out of a character
  ------------------------------------------------------------------------------
  function sscanf(value : character) return natural is
  begin
    if (value >= '0') and (value <= '9') then
      return(character'pos(value) - character'pos('0'));
    elsif (value >= 'a') and (value <= 'f') then
      return(character'pos(value) - character'pos('a') + 10);
    elsif (value >= 'A') and (value <= 'F') then
      return(character'pos(value) - character'pos('A') + 10);
    else
      return(0);
    end if;
  end sscanf;

  function sscanf(value : character) return nibbleUnsignedType is
  begin
    return(to_unsigned(sscanf(value), nibbleUnsignedType'length));
  end sscanf;

  function sscanf(value : character) return nibbleUlogicType is
    variable unsigned_value : nibbleUnsignedType;
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end sscanf;

  ------------------------------------------------------------------------------
  -- read an binary word out of a string
  ------------------------------------------------------------------------------
  function sscanf(value : string) return natural is
    variable integer_value : natural;
  begin
    integer_value := 0;
    for index in value'left to value'right loop
      integer_value := integer_value*16 + sscanf(value(index));
    end loop;
    return(integer_value);
  end;

  function sscanf(value : string) return unsigned is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := to_unsigned(0,unsigned_value'length);
    for index in value'left to value'right loop
      unsigned_value := shift_left(unsigned_value,4) + to_unsigned(sscanf(value(index)),4);
    end loop;
    return(unsigned_value);
  end;

  function sscanf(value : string) return std_ulogic_vector is
    variable unsigned_value : unsigned(4*value'length-1 downto 0);
  begin
    unsigned_value := sscanf(value);
    return(std_ulogic_vector(unsigned_value));
  end;

  ------------------------------------------------------------------------------
  -- read time from a string
  -- time can be formated as follows:
  --   "1ps" or "1 ps" or " 1 ps " or " 1ps"
  -- possible time units are: hr, min, sec, ms, us, ns, ps, fs
  ------------------------------------------------------------------------------
  procedure sscanf(
     value    : inout line;
     time_val : out time
  ) is
      variable time_line  : line := value;
      variable time_base  : string(1 to 3);
      variable time_value : integer;
      variable time_int   : time;
  begin
    -- remove all spaces and tabs
    rm_all_separators(time_line);

    -- strip time base (3 last characters)
    time_base := time_line(time_line'right-2 to time_line'right);

    -- separate time value and base
    if time_base(2 to 3) = "hr" then
        time_int   := 1 hr;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base = "min" then
        time_int   := 1 min;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base = "sec" then
        time_int   := 1 sec;
        time_value := integer'value(time_line(time_line'left to time_line'right -3));
    elsif time_base(2 to 3) = "ms" then
        time_int   := 1 ms;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "us" then
        time_int   := 1 us;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ns" then
        time_int   := 1 ns;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "ps" then
        time_int   := 1 ps;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    elsif time_base(2 to 3) = "fs" then
        time_int   := 1 fs;
        time_value := integer'value(time_line(time_line'left to time_line'right -2));
    else
        time_int   := 0 ps;
        time_value := 1;
    end if;

    -- build time from value and base
    time_val := time_int * time_value;

  end;

  function sscanf(value : string) return time is
    variable value_line : line;
    variable time_val   : time;
  begin
    value_line := new string'(value);
    sscanf(value_line, time_val);
    return(time_val);
  end;

END testUtils;




LIBRARY std;
  USE std.textio.all;
LIBRARY Common_test;
  USE Common_test.testUtils.all;

ARCHITECTURE test OF charToMorseController_tester IS
                                                              -- clock and reset
  constant clockPeriod: time := (1.0/clockFrequency) * 1 sec;
  signal sClock: std_uLogic := '1';
  signal sReset: std_uLogic := '1';
                                                              -- character input
  constant textToSend : string := "abcd efgh ijkl mnop qrst uvwx yz12 3456 7890";
  constant charInputDelay : time := 200 us;
  signal writePointer, readPointer : integer := 0;
  signal fifoDataAvailable: std_uLogic := '0';

BEGIN
                                                              -- clock and reset
  sClock <= not sClock after clockPeriod/2;
  clock <= transport sClock after clockPeriod*9/10;
  sReset <= '1', '0' after 2*clockPeriod;
  reset <= sReset;

  ------------------------------------------------------------------------------
                                                                -- test sequence
  testSequence: process
  begin
                                                              -- send characters
    for index in 1 to textToSend'length loop
      wait for charInputDelay;
      writePointer <= writePointer + 1;
    end loop;
                                                            -- end of fifo input
    print(cr & cr);
    assert false
    report "End of text"
      severity note;
    wait;
  end process testSequence;

  ------------------------------------------------------------------------------
                                                              -- fifo simulation
  fifo: process
  begin
                                                              -- wait for action
    wait until rising_edge(sClock);
                                                             -- add char in fifo
    if readChar = '1' then
      readPointer <= readPointer + 1;
    end if;
                                                            -- end of simulation
    if readPointer = textToSend'length then
      wait for charInputDelay;
      print(cr & cr);
      assert false
      report "End of simulation"
        severity failure;
    end if;
  end process fifo;

  char <= std_ulogic_vector(to_unsigned(
    character'pos(textToSend(readPointer+1)), char'length
  )) when (readPointer < textToSend'length) and (fifoDataAvailable = '1')
  else (others => '-');

  fifoDataAvailable <= '1' when readPointer < writePointer
  else '0';
  charNotReady <= not fifoDataAvailable;

END ARCHITECTURE test;




--
-- VHDL Architecture Morse_test.charToMorseController_tb.struct
--
-- Created:
--          by - Julie.UNKNOWN (LAPTOP-J400VU4F)
--          at - 01:53:40 02.04.2024
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

LIBRARY Morse;
LIBRARY Morse_test;

ARCHITECTURE struct OF charToMorseController_tb IS

    -- Architecture declarations
    constant characterBitNb: positive := 7;
    constant unitCountBitNb: positive := 3;
    constant unitDuration: real := 50.0E-6;
    constant clockFrequency: real := 60.0E6;
    --constant clockFrequency: real := 66.0E6;

    -- Internal signal declarations
    SIGNAL char         : std_ulogic_vector(characterBitNb-1 DOWNTO 0);
    SIGNAL charNotReady : std_ulogic;
    SIGNAL clock        : std_ulogic;
    SIGNAL done         : std_ulogic;
    SIGNAL morseOut     : std_ulogic;
    SIGNAL readChar     : std_ulogic;
    SIGNAL reset        : std_ulogic;
    SIGNAL startCounter : std_ulogic;
    SIGNAL unitNb       : unsigned(unitCountBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT charToMorseController
    GENERIC (
        characterBitNb : positive := 8;
        unitCountBitNb : positive := 3
    );
    PORT (
        morseOut     : OUT    std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        charNotReady : IN     std_ulogic ;
        char         : IN     std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        startCounter : OUT    std_ulogic ;
        unitNb       : OUT    unsigned (unitCountBitNb-1 DOWNTO 0);
        counterDone  : IN     std_ulogic ;
        readChar     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT unitCounter
    GENERIC (
        unitCountDivide : positive := 10E3;
        unitCountBitNb  : positive := 3
    );
    PORT (
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        startCounter : IN     std_ulogic ;
        unitNb       : IN     unsigned (unitCountBitNb-1 DOWNTO 0);
        done         : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT charToMorseController_tester
    GENERIC (
        clockFrequency : real;
        characterBitNb : positive
    );
    PORT (
        morseOut     : IN     std_ulogic ;
        readChar     : IN     std_ulogic ;
        char         : OUT    std_ulogic_vector (characterBitNb-1 DOWNTO 0);
        charNotReady : OUT    std_ulogic ;
        clock        : OUT    std_ulogic ;
        reset        : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : charToMorseController USE ENTITY Morse.charToMorseController;
    FOR ALL : charToMorseController_tester USE ENTITY Morse_test.charToMorseController_tester;
    FOR ALL : unitCounter USE ENTITY Morse.unitCounter;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_DUT : charToMorseController
        GENERIC MAP (
            characterBitNb => characterBitNb,
            unitCountBitNb => unitCountBitNb
        )
        PORT MAP (
            morseOut     => morseOut,
            clock        => clock,
            reset        => reset,
            charNotReady => charNotReady,
            char         => char,
            startCounter => startCounter,
            unitNb       => unitNb,
            counterDone  => done,
            readChar     => readChar
        );
    I_cnt : unitCounter
        GENERIC MAP (
            unitCountDivide => integer(clockFrequency*unitDuration + 0.5),
            unitCountBitNb  => unitCountBitNb
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            startCounter => startCounter,
            unitNb       => unitNb,
            done         => done
        );
    I_tester : charToMorseController_tester
        GENERIC MAP (
            clockFrequency => clockFrequency,
            characterBitNb => characterBitNb
        )
        PORT MAP (
            morseOut     => morseOut,
            readChar     => readChar,
            char         => char,
            charNotReady => charNotReady,
            clock        => clock,
            reset        => reset
        );

END struct;




